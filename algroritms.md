## 1. Системы исчисления

## 2. Битовые операции

## 3. BigO

## 4. Массивы
Массив это структур дыннх которая хранит один тип в порядке

Особенности:
* Фиксированный размер
* Индексация с нуля
* Быстрый доступ

Пример операций:

```java
public class Main {
    public static void main(String[] args) {
        // 1. Объявление и инициализация
        int[] numbers = new int[5]; // Массив на 5 элементов, заполнен нулями
        int[] fastInit = {10, 20, 30, 40, 50}; // Сразу с данными

        // 2. Чтение и запись (Сложность O(1))
        numbers[0] = 100; 
        int value = numbers[0];

        // 3. Проход по массиву (Итерирование)
        for (int i = 0; i < fastInit.length; i++) {
            System.out.println("Элемент под индексом " + i + ": " + fastInit[i]);
        }
    }
}
```
BigO^:
* Доступ по индексу O(1)
* Поиск значений O(n)
* Вставка(в начало/середину) O(n)
* Удаление O(n)

Пример задач и решение:
1. Инверсия массива: Напиши метод, который принимает массив целых чисел и разворачивает его задом наперед (например, [1, 2, 3] -> [3, 2, 1]). Подсказка: используй цикл и временную переменную для обмена значений.
```java
private static int[] revers(int[] array){
    for (int i=0;i<array.length/2;i++){//проходимся по половине массива
        int temp=array[i]; //берем элемент с начала
        int rightIndex=array.length-1-i;//индекс элемента с конца
        array[i]=array[rightIndex];//меняем их местами
        array[rightIndex]=temp;
    }
    return array;//возвращаем перевернутый массив
}
```
2. Поиск максимума и минимума: Найди самый большой и самый маленький элемент в массиве за один проход по нему.
```java
private static void SearchMaxMin(int[] array){
       int min=array[0];//инициализируем первым элеентом чтобы потом его пропустить 
       int max=array[0];
       for (int i=1;i<array.length;i++){
           if (array[i]>max)//если он больше первого, он становится максимальным и дальше сверяется с ним
           {
               max=array[i];
           }
           if (array[i]<min){//если он меньше первого, он становится минимальным и дальше сверяется с ним
               min=array[i];
           }
       }
        System.out.println("Max: "+max);
        System.out.println("Min: "+min);
    }
```
3. Удаление дубликатов (сложная): Дан отсортированный массив. Нужно «удалить» дубликаты так, чтобы каждый элемент встречался один раз. Можно просто вывести уникальные числа или вернуть новый массив.
```java
private static int[] duble(int[] array){//используем алгоритм двух указателей
        int q=0;//медленный указатель куда будем вставлять элемент
        for (int i=1;i<array.length;i++){
            if (array[i]!=array[q]){//если следующий элемент не равен элементу на нашем медленном указателе мы двигаем медленный указатель и вставляем туда наш элемент
                q++;
                array[q]=array[i];
            }
        }
    //при помощи медленного указателя мы посчитали количество уникальных элементов и добавляем 1, чтобы получить размер(так как это был индекс, а он начинается с нуля)
        int[] res=new int[q+1];
        for (int i=0;i<res.length;i++){//копируем в новый массив уникальные элементы
            res[i]=array[i];
        }
        return res;
    }
```
## 5. 2 указателя

Алгоритм основан на том что есть 2 указателя которые двигаются по структуре данных с определенной логикой

Виды:
* Встречное движение(Сходящие указатели)
* Скоростное движение(медленный и быстрый)
* Скользящее окно:2 указателя определяют границы окна которое движется по структуре данных

Пример задач и решение:
1. Проверка на палиндром: Дана строка. Проверь, читается ли она одинаково слева направо и справа налево, используя два указателя (один в начале, другой в конце).
```java
private static boolean polindrom(String str){//2 указателя идут навстречу друг другу и если их значение не равно сразу возвращаем false, то есть не палиндром 
        int q=str.length()-1;
        for (int i=0;i<str.length()/2;i++){
            System.out.println(str.charAt(q)+"  "+str.charAt(i));
            if (str.charAt(q)!=str.charAt(i)){
                return false;
            }
            q--;
        }
        return true;
    }
```
2. Перенос нулей: Дан массив [0, 1, 0, 3, 12]. Нужно переместить все нули в конец, сохранив порядок ненулевых элементов. Массив менять "на месте". (Используй быстрый и медленный указатели).
```java
private static int[] nulToStart(int[] array){
        int q=0;//индекс медленного указателя куда мы будем вставлять элемент
        for (int i=0;i<array.length;i++){
            if (array[i]!=0){//если элемент не ноль мы просто меняем местами с нашим медленным указателем
                int temp=array[q];
                array[q]=array[i];
                array[i]=temp;
                q++;
            }
        }
        return array;
    }
```
3. Слияние двух отсортированных массивов: Даны два отсортированных массива. Объедини их в один третий так, чтобы он тоже остался отсортированным. (Указатель на текущий элемент первого массива и указатель на текущий второго).
```java
private static int[] nulToStart(int[] array1,int[] array2){//здесь нам нужно 3 указателя на каждый массив и на результирующий
        int p1=0,p2=0,p3=0;
        int[] res=new int[array2.length+array1.length];//создаем массив нужного размера
        while(p1<array1.length&&p2<array2.length){//проходимся по массивам
            if (array1[p1]<array2[p2]){//если элемент первого массива меньше добавляем его 
                res[p3]=array1[p1];
                p1++;
            }else {//в обратном случае добавляем из второго массива 
                res[p3]=array2[p2];
                p2++;
            }
            p3++;//двигаем результирующий указатель
        }
        while(p1<array1.length){//добавляем оставшиеся элементы первого массива
            res[p3++]=array1[p1++];
        }
        while(p2<array2.length){//добавляем оставшиеся элементы второго массива
            res[p3++]=array2[p2++];
        }
        return res;
    }
```
## 6. Строки
Вся проблема строк, что это неизменяемый тип данных, структура данных схожая с массивом, строки привычный, читаемый вид данных  

Пример задач и решение:
1. Разворот строки (Reverse String)
```java
private static String reverseString(String str){
        char[] s=str.toCharArray();//преобразуем строку в массив
        int q=s.length-1;
        for (int i=0;i<s.length/2;i++)//при помощи алгоритма двух указателей переворачиваем ее
        {
            char temp=s[q];
            s[q]=s[i];
            s[i]=temp;
            q--;
        }
        return String.copyValueOf(s);//из массива символов делаем строку
    }
```
2. Проверка на анаграмму
   Даны две строки (например, "silent" и "listen"). Нужно проверить, являются ли они анаграммами (состоят ли из одних и тех же букв в одинаковом количестве).
```java
private static boolean anogram(String str,String s){
        if (str.length()!=s.length())return false;//если они разные по размеру, то это точно не анаграмма
        char[] firstStr=str.toCharArray();//переводим в массивы
        char[] secondStr=s.toCharArray();
        Arrays.sort(firstStr);//сортируем их
        Arrays.sort(secondStr);
        for (int i=0;i<firstStr.length;i++){//сверяем отсортированные массивы
            if (firstStr[i]!=secondStr[i]){//если хоть один элемент не равен, то это не анаграмма
                return false;
            }
        }
        return true;
    }
```
3. Самый длинный общий префикс (Longest Common Prefix)
   Дан массив строк: ["flower", "flow", "flight"]. Нужно найти самую длинную общую начальную часть. Здесь ответом будет "fl".
```java
private static String anogram(String[] str){
        StringBuilder prefix=new StringBuilder(str[0]);// мы берем за начальный префикс первую строку из массива

        for (int i=1;i<str.length;i++){//проходим по всему массиву кроме первого элемента
            if (str[i].isEmpty())return "";//если строка пустая возвращаем пустую строку, так как общего префикса не может быть
            while (str[i].indexOf(prefix.toString())!=0){//если строка начинается с нашего префикса метод вернет 0 и пока такого не будет, мы укорачиваем префикс
                prefix.deleteCharAt(prefix.length()-1);
            }
        }
        return prefix.toString();//возвращаем наш итоговый префикс
    }
```
## 7. Скользящее окно
Алгоритм скользящего окна заключается в том, что мы двигаемся не элементом, а отрезком(подмассивом)

Пример задач и решение:
1. Максимальная сумма подмассива длины K
   Дан массив [2, 1, 5, 1, 3, 2] и k = 3. Нужно найти максимальную сумму трех идущих подряд элементов.

```java
private static int maxSum(int[] array,int k){
        int maxSum=0;//ответ
        int windowSum=0;//значене текущего окна
        for (int i=0;i<k;i++){//просчитываем первое окно
            windowSum+=array[i];
        }
        maxSum=windowSum;
        for (int i = k; i < array.length; i++) {//идем дальше по массиву и отнимаем предыдущее значение и прибавляем следующее
            windowSum += array[i] - array[i - k];
            maxSum = Math.max(maxSum, windowSum);//сравниваем на максимум
        }
        return maxSum;
    }
```
2. (Динамическое окно): Самая длинная подстрока без повторений
```java
private static String uniqSubstring(String str){
        Set<Character> set=new HashSet<>();//в сет мы будем добавлять символ с правого указателя
        int maxLength=0;//самая длинная строка
        int bestIndex=0;//начало лучшей строки
        int left=0;//указатель на начало окна
        for (int right=0;right<str.length();right++){
            while(set.contains(str.charAt(right))){//если в сете есть элемент справа мы удаляем элементы слева пока не удалим дубликат
                set.remove(str.charAt(left));
                left++;
            }
            set.add(str.charAt(right));//добавляем элемент в сет
            if (right-left+1>maxLength){//проверка на самую длинную строку  
                maxLength=right - left + 1;
                bestIndex=left;
            }
        }
        return str.substring(bestIndex,bestIndex+maxLength);
    }
```
3. 
## 8. Матрицы

## 9. Интервалы

## 10. Стек

## 11. Очередь

## 12. Монотонная последовательность

## 13. Связные списки

## 14. Хэш-таблицы

## 15. Рекурсия

## 16. Поиск с возвратом

## 17. Двоичное дерево

## 18. Двоичное дерево поиска

## 19. Двоичная куча

## 20. Префиксное дерево

## 21. Граф поиск в глубину

## 22. Поиск в ширину

## 23. Сортировки

## 24. Двоичный поиск

## 25. Мемоизация

## 26. Табуляция