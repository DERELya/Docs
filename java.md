# **Модуль 1**

##    1.	**JVM, JRE, JDK**
Jvm это java virtul machine – виртуальная машина переводит байт-код в машинный, который после выполняется операционной системой именно благодаря этому достигается кроссплатформенность.
JRE(Java Runtime environment) это пакет, который предоставляет минимальную среду для выполнения Java приложений(JRE=JVM+библиотеки).
JDK(Java development kit) это полный набор инструментов для разработки, компиляции, отладки и запуска Java приложений. Состоит из JRE и инструментов разработки.
Инструменты разработки:
   1.	Компилятор, который переводит java код в байткод (файлы java в class)
   2.	Java application launcher запускает приложения используя JVM и JRE
   3.	Java debugger отладчик для поиска ошибок
   4.	Генерация документации
      5.	Jar для создания и управления jar архивами 

##    2.	**Области памяти в java**

Память, которую использует JVM разбита на 5 основных областей:
   1.	Куча(Heap)это область памяти которая доступная каждому потоку(глобальная память) хранит все объекты и массивы(созданные при помощи слова new). Память в куче контролируется сборщиком мусора
   2.	Стек (stack) используется для выполнения потоков(у каждого потока свой стек), порядок в стеке работает по принципу последним пришел, первым ушел(Last in First out LIFO) это делает выделения и освобождение памяти очень быстрым. Стек хранит фреймы в фрейме хранятся локальные переменные, параметры(аргументы) метода, частичные вычисления и точка возврата(куда нужна вернуться после завершения метода) фрейм создается при каждом вызове метода и уничтожается по завершению.
   3.	Область методов хранит структуру всех загруженных классов и интерфейсов, информацию о полях и методах, статические переменные и пул констант времени выполнения. Эта область доступна для каждого потока
   4.	Регистр счетчик программы хранит адрес на следующую инструкцию байт-кода для текущего потока. Каждый поток имеет свой собственный регистр PC(program counter) 
   5.	Стек нативных методов хранит нужен для возможности использовать нативные методы. Каждый поток имеет свой нативный стек

##   3.	**Class Loaders. Виды, для чего нужны**

Это механизм загрузки классов, который позволяет динамически загружать классы в память когда они необходимы, а не все сразу. Загрузчики создают пространство имен для каждого класса это позволяет использовать несколько версий одного класса, также они отделяют пользовательские классы от системных. Существует 3 основных загрузчика классов:
      1. Bootstrap самый первый и родительский, загружает основные библиотеки JAVA, является частью JVM, написанный на нативном коде
      2. Extension(загрузчик расширений) дочерний по отношению к bootstrap и загружает классы из $JAVA_HOME/jre/lib/ext/ для дополнительных возможностей 
      3. Системный загружает классы специфичные для вашего приложения, он ищет классы в Class path
      4. Пользовательские. Пользователи сами могут создать загрузчик наследуя от класса ClassLoader позволяет загружать классы из нестандартных мест например из сети, бд, зашифрованных jar

## 4.Объект класса Class

 Объект Class это описание самого типа, какие поля содержит, методы, конструкторы, интерфейсы, супер класс, пакет, аннотации 
Получить объект Class можно при помощи:
1.	
```java
.class <String> stringClass = String.class;
```
2.	через метод getClass()
```java
String s = "Hello";
 Class<?> objectClass = s.getClass();
```
3.	через статический метод forName()
```java
Class<?> classObj = Class.forName("java.util.HashMap");
```

Метод Class	Описание
getName()	Возвращает полное имя класса (с пакетом).
getSimpleName()	Возвращает имя класса без имени пакета.
getSuperclass()	Возвращает объект Class суперкласса.
getInterfaces()	Возвращает массив объектов Class реализованных интерфейсов.
getFields(), getMethods(), getConstructors()	Возвращают массивы объектов Field, Method и Constructor (публичные).
getDeclaredFields(), getDeclaredMethods(), getDeclaredConstructors()	Возвращают все объявленные элементы, включая приватные.
newInstance() (устарел) или getDeclaredConstructor().newInstance()	Создает новый экземпляр этого класса.

## 5. Классы и объекты

Класс это описание сущности: какие поля должна содержать, какие методы реализованы.
Объект это экземпляр класса который обладает своим состоянием и своими значениями.
Интерфейс это набор методов класса доступные для использования.
Пример: человек это класс у него есть рост, вес, возраст, имя, пол, а вот конкретный человек Саша,29,180,90,мужчина это объект(экземпляр класса) и он умеет рисовать, читать, писать это как раз интерфейс
```java

class Car {// Поля (состояние/атрибуты)
    String model;
    String color;
    int speed;

    // Методы (поведение)
    void startEngine() {
        // Логика запуска двигателя
    }

    void accelerate(int increase) {
        speed += increase;
    }}
```

Объект
```java
Car car1 = new Car(); // Объект 1

// Объект 1: имеет свое уникальное состояние
car1.model = "Toyota";
car1.color = "Red";
car1.speed = 0;
```
## 6. Структура класса

Структура класса состоит из:
1.	Модификатора доступа (откуда будет виден класс) обычно это public виден в любом месте
2.	Ключевого слова Class обязательное для определения
3.	Название класса с заглавной буквы(Person)
4.	Наследование (extends) указывает на родительский класс 
5.	Интерфейсы (implements) указывается какие интерфейсы класс должен реализовать
Пример:
```java
public class ClassName extends SuperClass implements Interface1, Interface2 {
    // Тело класса
}
```

Класс может содержать поля, методы и вложенные классы

## 7. Поля

Поля это данные которые содержит сущность например у класса человек есть поля возраст, рост, имя 

## 8. Конструкторы(ключевое слово super и this)

Конструктор это метод которые вызывается при создании экземпляра класса, их может быть несколько, его задача инициализация, задать начальные значения полям объекта. У него нет возвращаемого типа данных и если вы не напишите сами конструктор, будет использоваться конструктор по умолчанию.
Ключевое слово this ссылается на текущий экземпляр класса внутри которого оно используется.

```java
public Car(String color) {// 'color' справа — это параметр метода
    // 'this.color' слева — это поле экземпляра класса
    this.color = color;}
```
Можно использовать для вызова другого конструктора this(…)
Слово super используется для доступа к членам родительского класса, конструкторы не наследуются и первым инструкцией в теле должно быть super(…) таким образом вызывается родительский конструктор.

```java
class Vehicle {  
    String type;
    public Vehicle(String type) {     
        this.type = type;    }
}

class Car extends Vehicle {
    int doors;

    public Car(String type, int doors) {
        super(type); // ⬅️ Вызывает конструктор Vehicle(String)
        this.doors = doors;
    }
}
```
Также можно вызывать методы родителя и получать доступ к полям.

## 9. Методы(сигнатура методов, перегрузка методов)

Сигнатура метода включает в себя имя и список аргументов (!!!возвращаемый тип данных и модификатор доступа не входит в сигнатуру метода)
public void say(String message)
Сигнатура здесь будет say(string)

Перегрузка метода это возможность использовать несколько методов с одинаковым именем, но разными сигнатурами. Это достигается изменением сигнатуры: разный порядок параметров (если типы отличаются), разный тип параметров, разное количество параметров.
Перегрузка (Overloading) происходит в одном классе, это механизм полиморфизма

Перегрузка — это когда в одном классе есть несколько методов с одинаковым именем, но разными параметрами.
## 10. Статические и нестатические блоки инициализации

Нестатические блоки инициализации — это блоки кода заключенные в фигурные скобки «{}» внутри класса и до конструктора, выполняется каждый раз при создании нового экземпляра класса при помощи new, 
пример:
```java
public class NonStaticDemo {    private int counter;
    
    // Нестатический блок инициализации
    {
        counter = 1;
        System.out.println("Нестатический блок выполнен. Counter: " + counter);
    }
    
    public NonStaticDemo() {
        System.out.println("Конструктор выполнен.");
    }
    }
   ```
Статические блоки инициализации вызываются один раз для загрузки в JVM при первом создании экземпляра класса или при первом доступе к статическому полю и заключены в фигурные скобки «{}» но перед блоком еще нужно ключевое слово static, выполняется до конструкторов и до любых нестатических блоков.
```java
public class StaticDemo {    private static int loadCount;

    // Статический блок инициализации
    static {
        loadCount = 0;
        System.out.println("Статический блок выполнен. Класс загружен.");
    }
    
    public StaticDemo() {
        loadCount++;
        System.out.println("Объект создан. Общее количество: " + loadCount);
    }
}
```

## 11. Модификаторы

Модификаторы — это ключевые слова, которые добавляются к определению классов, полей, методов, конструкторов. Они делятся на модификаторы доступа, которые определяют уровень видимости и модификаторы не доступа они определяют другие характеристики не связанные с уровнем видимости

## 12. static, final, abstract

**Static** говорит о том что поле или метод принадлежит классу, а не конкретному объекту, для всех объектов существует только она копия статического поля.

**Final** запрещает наследование, переопределение и изменение 
Для классов значит что запрещено наследование.
Для полей это значит что поле будет константой(значение присвоено один раз)
Для методов что он не может быть переопределен в подклассах.

**Abstract** используется для создания абстрактных структур(шаблонов)
Для класса нельзя создать объект этого класса, он может содержать абстрактные методы.
Для метода не пишется реализация, а только объявляется и подкласс обязан его реализовать.

## 13. private, protected, public, package private

* Private виден только в классе
* Protected виден только том же классе, подклассах, в том же пакете
* Public виден везде
* Package private ставится по умолчанию, виден только в том же пакете

## 14. Варианты установки значений свойств объектов

Варианты делятся на два основных этапа: инициализация (пи создании объекта) и изменение(после создания)
1. через конструктор 
```java
public class Book {
    private String title;
    
    // Конструктор
    public Book(String title) {
        this.title = title; // Установка значения через параметр
    }
} 
```
2. нестатический блок инициализации
```java
public class Box {
    private int volume;
    // Блок инициализации
    {
        this.volume = 100; // Установка значения по умолчанию
    }
   ```
3. прямая инициализация 
```java
public class Person {
    private String species = "Human"; // Прямая инициализация
    private int age = 0;
}
```
4. при помощи сеттера 
```java
public class Person {
    private int age;
//сеттер для возраста	
public void setAge(int age){
	this.age=age;
    }
}
```
5. прямой доступ к полю
```java
public class Person {
    public int age;
}
Person person=new Person();
person.age=10;

```
## 15. Поля, конструктор, сеттеры(плюсы, минусы каждого)

Поля это переменная в классе, изменение ее через прямой доступ(самый быстрый и простой синтаксис из минусов это нарушение инкапсуляции, невозможно валидировать данные, изменение имени поля приводит к тому что нужно менять везде где используется)

Конструктор:гарантирует что объект создается валидным и  полным, обеспечивает неизменяемость если поля final

Минусы: 
1. при большом количестве полей конструктор может быть большим
2. Не позволяет изменять поля
3. Требует перегрузки для набора разных параметров 

Сеттеры

###### Плюсы:

* Позволяет проводить валидацию.
* Позволяет изменять поля после его создания.
* Обеспечивает инкапсуляцию.

###### Минусы:

Не всегда нужен если объект final 

## 16. Абстрактные классы и интерфейсы(отличия, где что лучше использовать)
Абстрактный класс это класс который служит шаблоном, он может иметь частичную реализацию(базовый код), обычно от него наследуют другие классы, а он имеет поля и методы которые необходимы всем наследникам.

У него тесная связь("является") например Animal(абстрактный класс) и класс наследник Cat, мы можем утверждать, что кот является животным и он будет иметь поля животного, методы нужно переопределить в наследнике. Мы не можем создать объект абстрактного класса, но мы можем сделать так:
```java
Animal a = new Dog(); // допустимо
a.makeSound();        // вызов метода Dog
```
Пример абстрактного класс:
```java
public abstract class Vehicle{
    public int numPassengers;
    public double weight;
    public double fuel;
    public double maxSpeed;
    public int numWheels;
    public double speed;

    public abstract void startMoving();
    public void StopMoving(Vehicle vehicle){
        vehicle.speed=0;
        vehicle.fuel=this.fuel;
    }
}
```

Интерфейс это набор абстрактных методов,которые класс обязуется реализовать.
Пример:
```java
public interface Drivable {
    void accelerate();
    void brake();
}
```
Для использования интерфейсов необходимо ключевое слово `implements` 
```java
public class Car implements Drivable {
    public void accelerate() {
        System.out.println("Car speeds up");
    }

    public void brake() {
        System.out.println("Car slows down");
    }
}
```
Интерфейсы могут наследовать другие интерфейсы и тогда он включает все методы интерфейса родителя, значит класс должен будет реализовать все методы (потомка и родителя).

default метод в интерфейсе — это действительно стандартная реализация, которую можно использовать по умолчанию, если класс не переопределяет её.

static метод в интерфейсе принадлежит самому интерфейсу, а не объекту, и вызывается по имени интерфейса и его нельзя переопределить.

Нельзя создать объект типа интерфейса, можно так:
```java
Drivable d = new Car(); // ✅ Car реализует Drivable
d.accelerate();
```
##### Отличия:

1. классы могут наследовать только один абстрактный класс, но при этом могут реализовывать множество интерфейсов
2.  в абстрактном классе может быть частичная реализация, когда как интерфейс полностью абстрактный.
3.  в абстрактном классе могут быть любые поля, а в интерфейсе только public static final константы 
4.  в абстрактном классе есть конструктор, в интерфейсе нет
5.  связь при использовании абстрактного класса тесная иерархия, используя интерфейсы будет контрактная связь («может делать»)

##### Когда что использовать:

###### Абстрактные классы:

1. когда требуется тесная связь(Animal->cat,dog)
2. общий код(базовая реализация)
3. для хранения состояния 

###### Интерфейсы:

1. для определения контракта
2. множественное поведение например: пингвин может плавать и есть 
3. отделить определение от реализации
4. гибкость другие разработчики смогут добавлять реализацию контракта  не будучи ограниченными иерархией

## 17. Изменяемые и неизменяемые объекты(примеры неизменяемых классов в java, как сделать класс неизменяемым)

Неизменяемые объекты(immutable) — это объекты состояние которых нельзя изменить, любая операция, которая должна изменить объект, на самом деле возвращает новый объект, а исходный остался нетронутым.

##### Плюсы:

* Потокобезопасность так как объект неизменяемый не нужно заботиться о синхронизации
* Простота хэширования такой объект можно легко хэшировать и его хеш-код вычислять один раз
* Идеально подходят для ключей, так как хеш код не меняется (HashMap, HachSet)

Примеры: String, классы обертки (Integer, Double, Boolean, Character), BigDecimal, BidInteger, классы дат и времени LocalDate, LocalTime, ZonedTimeZone и т.д.

Изменяемые (mutable) объект может изменяться после его создания.

Примеры:
StringBuilder, StringBuffer для работы со строками
Большинство коллекций HashMap, ArrayList.

##### Чтобы сделать класс неизменяемым нужно:

1. Его объявить с использованием final(это предотвращает наследование так как подкласс мог бы переопределить методы) 
2. Все поля private final чтобы private скрывает поля, final делает их неизменяемыми
3.  Отсутствие методов сетторов чтобы нельзя было изменить поля класса
4.  Инициализировать поля в конструкторе, гарантирует, что объект будет инициализирован в момент создания 
5.  Глубокое копирование изменяемых полей

Если класс имеет ссылку на изменяемый объект, мы должны избежать его изменения и делать копирование:
* В конструкторе не сохранять прямую ссылку, вместо этого сохранять копию
* В геттере возвращать копию объекта
Пример:
```java
import java.util.Date;

public final class ImmutableStudent { // 1. Класс final
    
    private final int id;             // 2. Поля private final
    private final String name;        // 2. Поля private final
    private final Date birthDate;     // 2. Поле - ссылка на изменяемый объект Date

    // 4. Инициализация только в конструкторе
    public ImmutableStudent(int id, String name, Date birthDate) {
        this.id = id;
        this.name = name;
        // 5a. Глубокое копирование: сохраняем копию Date
        this.birthDate = new Date(birthDate.getTime());
    }
    
    // 3. Нет сеттеров
    
    // Геттеры
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Date getBirthDate() {
        // 5b. Глубокое копирование: возвращаем копию Date
        return new Date(this.birthDate.getTime());
    }
}   
```
## 18. Inner и Nested классы

Вложенные классы (Nested) — это класс, объявленный внутри другого класса, они бывают двух видов:
* Статические вложенные (static nested class) и внутренние класс (inner class)
* Статический вложенный класс объявляется со словом static. Он не имеет доступ к нестатическим полям и методам внешнего класса, только к статическим, создается при помощи имени внешнего класса даже без создания его экземпляра.

Внутренний класс — это нестатический вложенный класс
Он всегда связан с конкретным экземпляром внешнего класса и имеет полный доступ к его полям и методам (даже private) 

## 19. Локальные и анонимные классы

Локальный это класс, объявленный внутри метода или другого блока
* Виден только внутри метода или блока, где инициализирован
* Имеет доступ ко всем полям внешнего класса, потому что связан с экземпляром класса
* Нельзя использовать private, public, protected
Пример:
```java
public class Outer {
    void display() {
        int limit = 100; // Эффективно final
        
        class LocalPrinter { // ⬅️ Локальный класс
            public void print() {
                System.out.println("Limit from method: " + limit); // Доступ к 'limit'
            }
        }
        
        LocalPrinter lp = new LocalPrinter();
        lp.print();
    }
}
```
Анонимный класс — это класс, который не имеет имени, используется для создания объекта, чтобы реализовать интерфейс или абстрактный/конкретный класс

Выражение new InterfaceName/ClassName() {... } создает и немедленно возвращает единственный экземпляр анонимного класса.
Нельзя создать второй экземпляр такого класса
Не может объявлять конструктор так как не имеет имени 
Пример:
```java
interface Greeting {
    String greet();
}

public class AnonDemo {
    public void executeGreeting() {
        // ⬅️ Анонимный класс, реализующий интерфейс Greeting
        Greeting spanishGreeting = new Greeting() { 
            @Override
            public String greet() {
                return "Hola!";
            }
        }; 
        System.out.println(spanishGreeting.greet());
    }
}
```
Сейчас обычно используется лямбда-выражение 

## 20. Класс Object

Это корень иерархии всех классов в Java, все классы явно или неявно наследуются от класса Object. Это означает что каждый объект наследует методы Object.

## 21. Методы класса Object

1.	`Equals(obj)` используется для сравнения на логического равенство двух объектов по умолчанию сравнивает по ссылке(указывают ли на один объект в памяти), почти всегда необходимо переопределять для того, чтобы сравнивать на основе их состояния.
2.	`hachCode()` используется чтобы вернуть хеш-код объекта для эффективного хранения и поиска объектов в хеш-коллекциях(HashSet, HashMap), если вы переопределили equals(), вы обязаны и переопределить и hashCode(если объекты равны по equals, то они обязаны иметь один хеш-код)
3.	`toString()` создает и возвращает копию объекта, обычно возвращает имя класса и после знака @ хеш-код, обычно переопределяется чтобы получать полезную и читаемую информацию
4.	`clone()` создает и возвращает копию объекта, требуется чтобы класс реализовал интерфейс Cloneable(который является маркерным и интерфейсом, не имеющий  методов), выполняет поверхностное копирование
5.	`wait(), notify(),notifyAll()` используются для межпоточного взаимодействия, должны вызываться только внутри синхронизированного блока или метода так как работают с блокировкой объекта
Класс Object так важен, потому что от него наследуются все классы и любой объект может быть обработан как Object.
Любая коллекция может хранить любой тип, потому что ее методы add(Object e) работают с общим родительским  типом. Это основа для обобщенного программирования в Java.

## 22. Контракт equals – hashcode

Контракт это набор правил которые должны быть выполнены для переопределения методов equals(), hashcode()
1.	Согласованность если объекты равны по equals, то и хеш-коды должны быть одинаковыми
2.	Если два хеш-кода равны это не гарантирует, что они равны по equals, это называется коллизией хеш-кодов. Хеш-код используется для быстрого поиска, а equals для окончательной проверки
3.	Если информация, используемая в сравнении equals не изменилась, то многократный вызов hashCode() должен возвращать один и тот же хеш-код
Нарушение правил ведет к не предсказуемому поведению, например изменение хеша после его помещения в таблицу придет к тому, что объект потеряется в памяти и его нельзя будет получить по ключу, но он будет занимать память
Рекомендации: 
	Использовать одни и те же поля в equals() и hashCode(), для неизменяемых объектов хранит хеш-код в final поле

## 23. Метод clone

Clone() создает и возвращает копию объекта, для его использования класс должен реализовывать интерфейс Cloneable, так как clone() в Object объявлен protected, мы должны переопределить его с модификатором public чтобы могли использовать вне класса.
Есть два типа копирования:
1.	Поверхностное копирование оно копирует значения примитивных полей и ссылок на объекты, это приводит к тому, что если у одного клона изменить значение вложенного объекта он измениться во всех клонах
2.	Глубокое копирование требует ручной реализации, вызывается super.clone() для поверхностного копирования, для всех изменяемых ссылочных типов создается и присваиваются новые экземпляры, в результате клонированный объект полностью независим от оригинала.
Пример глубокого копирования:
```java
@Override
    public Object clone() throws CloneNotSupportedException {
        // 1. Поверхностное копирование: создается новый объект Person и копируются поля name и ссылка address
        Person clonedPerson = (Person) super.clone();
        
        // 2. Глубокое копирование: создается новая копия объекта Address
        // Это предотвращает совместное использование Address оригиналом и клоном.
        clonedPerson.address = (Address) this.address.clone();
        
        return clonedPerson;
    }
   ```
Как альтернатива можно использовать конструктор копирования где мы просто копируем поля экземпляра.

Пример:
```java
public Person(Person other) {
    this.name = other.name;
    this.address = new Address(other.address.getCity()); // Вручную создаем копию Address
}
```
## 24. Принципы ООП

1.	Инкапсуляция — это сокрытия методов и полей от пользователя
2.	Полиморфизм позволяет нам использовать объекты с одинаковыми интерфейсами без знаний структуры и типа объекта.
3.	Наследование позволяет нам наследовать поля и методы от класса родителя
4.	Абстракция позволяет нам выделить общие характеристики и методы в один класс, а после наследоваться от него
 
## 25. Наследование и Ассоциация (определение, плюсы-минусы каждого)

Наследование  механизм, при котором один класс получает свойства и методы другого класса(отношение «является») например dog является animal, родитель animal и дочерний класс dog.

###### Плюсы:

* Повторное использование кода, так как дочерний класс имеет доступ к полям и методам родителя
* Полиморфизм позволяет использовать объект дочернего класса где ожидается родительский
* Создает четкую иерархию классов

###### Минусы:

* Тесная связь: любое изменение в классе родителе отразиться на дочернем, кроме добавления методов
* Java поддерживает только одиночное наследование
* Нарушение инкапсуляции, так как раскрываем детали реализации родителя

Ассоциация — это общее понятие, описывающее структурную связь между двумя или более классами (отношение «имеет»), реализуется через композицию или агрегацию, класс содержит ссылку на другой класс в виде поля, это позволяет использовать функциональность другого объекта.

В композиции отношение «часть-целое» где часть не может существовать без целого, при уничтожении целого уничтожается и часть

В агрегации отношение такое же, но часть может существовать без целого 

###### Плюсы:

* Классы слабо зависят друг от друга, что упрощает изменения
* Гибкость: позволяет легко изменять какой объект использовать (можно заменить объект на другой)
* Инкапсуляция: внутренние детали ассоциированного объекта скрыты

###### Минусы:

* Требуется ручное написание кода для делегированного вызова ассоциированному объекту
* Для реализации сложных отношений может потребоваться написать больше кода чем при простом наследовании
###### Сравнение ассоциации и наследования:

* Отношение: в наследовании это «является» в ассоциации это включение («имеет»)
* Связанность: в наследовании тесная, в ассоциации слабая
* Принцип ООП: полиморфизм, повторное использование кода в наследовании и инкапсуляция, делегирование в ассоциации 

## 26. Переопределение методов

Переопределение методов — это механизм Java позволяющий дочернему классу предоставлять собственную реализацию метода, который определен в родительском классе

###### Правила переопределения:
1.	Сигнатура метода должна сохраняться (такая же, как в родительском классе)
2.	Метод должен быть определен в родительском классе и дочерний должен его наследовать
3.	Переопределенный метод не может иметь более ограничивающий модификатор доступа чем в суперклассе, например если в родителе protected, то у потомка protected или public 
4.	Переопределенный метод не должен объявлять новые исключения, он может использовать меньше чем в родителе или подклассы исключений
5.	Методы, объявленные как private, static, final не могут быть переопределены 

Рекомендуется использовать аннотацию @override так компилятор поймет, что вы переопределяете метод и выдаст ошибку в случае ошибки в сигнатуре 

Благодаря этому реализуется динамическая диспетчеризация: JVM решает какой метод вызвать во время выполнения, а не компиляции основываясь на фактическом типе объекта, на который ссылается переменная например:
```java
Animal myAnimal = new Dog(); // Ссылка типа Animal, объект типа Dog
myAnimal.makeSound(); // Вызовет Dog.makeSound() -> "Dog barks."
// Если бы не было переопределения, был бы вызван метод Animal. 
```
## 27. Статическое и динамическое связывание

Связывание — это процесс сопоставления вызова метода с его конкретной реализацией.

В Java оно может быть статическим (во время компиляции) и динамическим (во время выполнения)

Статическое связывание происходит во время компиляции, компилятор выбирает реализацию на основе типа ссылки.

###### Когда происходит:

1.	Статические методы, потому что они принадлежат классу 
2.	Final методы они не могут быть переопределены 
3.	Private методы они не наследуются и не могут быть переопределены
4.	Поля: доступ к полям всегда происходит статически
5.	Перегрузка методов: компилятор выбирает на основе типов аргументов во время компиляции

Динамическое связывание происходит во время выполнения JVM определяет какой метод вызвать на основе фактического типа объекта, на который ссылается переменная, происходит обычно с переопределенными методами

## 28. Оболочки примитивных типов. Основное API. Особенности сравнения значений.

Оболочки примитивных типов это классы которые предоставляют объектный эквивалент для каждого примитивного типа(int->Integer, Boolean->Boolean, char->Charactet)

Автоупаковка и автораспаковка это автоматический процесс преобразование примитивного типа в его объектную оболочку и наоборот

###### Основное API:
1.	Методы преобразования эти методы используются для преобразования строки в примитивный тип (parseInt(String s)) 
2.	Методы получения значений каждый класс-оболочка имеет метод для получения своего значения в виде примитивов (intValue())
3.	Методы преобразования в объект: эти методы используется для преобразования примитивов или строк в объект оболочку, они могут использовать кеш valueOf(int i) , valueOf(String s)
4.	Большинство числовых оболочек предоставляют константы Integer.MAX_VALUE , Double.NEGATIVE_INFINITY

###### Особенности сравнения значений 
1.	Оператор сравнения «==» сравнивает ссылки двух объектов 
```java


Integer a = 100;
Integer b = 100;
System.out.println(a == b); // true

Integer c = 500;
Integer d = 500;
System.out.println(c == d); // false
```
Большинство классов оболочек (кроме Double и Float) кэшируют данные в диапазоне -128 до 127
2.	Для логического сравнения необходимо использовать equals()
3.	Смешанное сравнение (примитив и оболочка), при таком сравнении оболочка автоматически распаковывается до примитива.


## 29. String

String это неизменяемый класс, который содержит последовательность символов.

String неизменяемый это значит что при любом действие которое казалось бы изменяет строку, на самом деле создает новый объект. Это обеспечивает потокобезопасность и также позволяет использовать пул строк.

## 30. String pool

Пул строк — это специальная область в памяти(куче) для литералов.

Если мы создаем строку литералом
 `String s = "Hello";`
То вначале JVM проверяет пул на наличии такого литерала и если он есть возвращает ссылку на существующий объект в памяти, если же нет, то создает его и возвращает ссылку. Когда мы создаем строку при помощи new всегда создается новая строка в куче (вне пула) даже если строка там есть.
При помощи метода `intern()` мы можем строку переместить из кучи в пул, если такая строка уже есть в пуле, мы вернем ссылку на объект.

## 31. API

* `equals(Object other)` Сравнивает содержимое строк (регистрозависимо).
* `equalsIgnoreCase(String other)` Сравнивает содержимое строк (без учета регистра).
* `compareTo(String other)` Сравнивает строки лексикографически (используется для сортировки).
* `indexOf(char/String)`	Возвращает индекс первого вхождения символа/подстроки.
* `contains(CharSequence s)`	Проверяет, содержит ли строка указанную последовательность.
* `substring(int begin, int end)`	Возвращает новую строку — подстроку.
* `replace(char old, char new)`	Возвращает новую строку с заменой символов.
* `trim()`	Возвращает новую строку, удаляя начальные и конечные пробелы.
* `length()`	Возвращает длину строки.
* `charAt(int index)`	Возвращает символ по указанному индексу.
* `toUpperCase(), toLowerCase()`	Возвращает новую строку в верхнем/нижнем регистре.
* `split(String regex)`	Разбивает строку на массив строк по заданному разделителю (регулярному выражению).

## 32. StringBuilder, StringBuffer

Эти классы используются для работы с изменяемыми строками, они позволяют изменять объект, что делает их более эффективными для сложных манипуляций.

StringBuilder в основном используется когда работа происходит в одном потоке, так как он быстрее, но не синхронизированный

StringBuffer является потокобезопасным, он медленнее из-за использования блокировок, все его публичные методы синхронизированы, значит что только один поток может изменять в данный момент времени.

###### Основные методы:

* `append(...)`	Добавляет строку, примитив или символ в конец последовательности.
* `insert(int offset, ...)`	Вставляет строку или другой тип данных в последовательность по указанному индексу.
* `delete(int start, int end)`	Удаляет символы в указанном диапазоне.
* `reverse()`	Изменяет последовательность символов на обратную.
* `capacity()`	Возвращает текущую емкость (выделенное место в памяти).
* `toString()`	Преобразует изменяемую последовательность обратно в неизменяемый объект String (этот метод создает новый объект String). 

## 33. Алгоритмы

Алгоритм — это последовательность инструкций или правил для решения какой-либо задачи или получения результата

Основные характеристики:
1.	Дискретность алгоритм должен завершаться через конечное число шагов
2.	Определенность каждая инструкция должна быть четкой и не иметь двойного толкования
3.	Вход алгоритм должен принимать ноль или больше аргументов
4.	Выход алгоритм должен производить один или более результатов (решения задачи)
5.	Эффективность каждая операция должна быть простой чтобы ее можно было выполнить за конечное время

###### Анализ сложности алгоритмов:

1.	Временная сложность описывает время выполнения алгоритма, зависящее от размера входных данных.
2.	Пространственная сложность описывает какой объем памяти требуется для выполнения алгоритма, растет с увеличением размера входных данных. 

## 34. Big O notation(какие виды временной сложности алгоритмов бывают)

Для формального описания сложности используется O-нотация, она описывает асимптотическую сложность алгоритма(то как он себя ведет при больших входных данных)

* O(1) Постоянная (Доступ к элементу массива по индексу).
* O(log N) Логарифмическая (Бинарный поиск.)
* O(N) Линейная (Поиск максимального элемента в несортированном массиве.)
* O(N log N)} Линеарифмическая (Эффективные алгоритмы сортировки (Merge Sort, Heap Sort).)
* O(N^2) Квадратичная (Простые алгоритмы сортировки (Bubble Sort, Insertion Sort).)
* O(2^N) Экспоненциальная (Решение задачи коммивояжера методом грубой силы.)


## 35. Виды сортировок(отличие quicksort от merge sort)

###### 1.	Простые

Подходят для небольших наборов данных, медленные на больших массивах(сортировка пузырьком, сортировка выбором, сортировка вставками ) 

###### 2.	Эффективные

Стандарт для сортировки больших массивов(Сортировка слиянием, быстрая сортировка, пирамидальная сортировка)

###### Отличия quicksort mergeSort:

Это два эффективных алгоритма сортировки, основанные на принципе «разделяй и властвуй» 
* Средняя сложность: у них одинаковая O(N log N)
* Сложность наихудшая: у быстрой O(N^2), а у слиянием O(N log N)
* Быстрая сортировка нестабильная, а слиянием стабильная
* Подход: у быстрой сортировки разделение сложное, слияние простое, вся работа будет на этапе разделения. У сортировки слиянием разделение простое, а слияние сложное, массив делится пополам, и вся работа делается на этапе слияния двух отсортированных подмассивов
* Память: у быстрой O(log N) или O(N) для рекурсии, для сортировки слиянием всегда требуется O(N) 
* Рекурсия: Быстрая сортировка использует хвостовую рекурсию, а сортировка слиянием не хвостовую

Быстрая сортировка быстрее благодаря лучшему использованию кеша процессора, но может сломаться на плохо выбранных данных(уже отсортированный массив)
Сортировка слиянием более надежная, используется когда нужна стабильность и память не играет ключевую роль

## 36. Generics

Дженерики это мощная функция которая позволяет создавать классы, методы и интерфейсы, работающие с различными типами данных.
Назначение: 
1.	Безопасность типов: дженерики гарантируют что в коллекцию или метод будет помещен объект ожидаемого типа.
2.	Устранение приведения: при получении объекта из коллекции не нужно явно приводить объект
3.	Повторное использование кода: один класс дженерик можно использовать для разных типов  

###### Ключевые понятия:

1.	Параметризованные типа:
* T(type) общий заполнитель для любого типа
* E(element) используется для элементов коллекций
* K(key) V(value) используется для пар ключ значение 
2.	Дженерик класс
```java
// Класс, который может хранить объект любого типа T
public class Box<T> {
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}

// Использование
Box<Integer> integerBox = new Box<>();
integerBox.set(10);
Integer x = integerBox.get();
```
3.	Дженерик метод

Параметризированный метод, который можеть быть объявлен как в обычном классе, так и в классе-дженерике
```java
// Параметр типа <T> объявляется перед типом возвращаемого значения
public static <T> void printArray(T[] array) {
    for (T element : array) {
        System.out.println(element);
    }
}
```

###### Ограничение типов

По умолчанию любой дженерик может быть заменен любым не примитивом, ограничения позволяют указать что Т должен быть подклассом определенного класса или реализовывать определенный интерфейс.

Ограничения через extends используются для ограничения верхней границы
```java
public class NumericBox<T extends Number> {
    // Теперь T гарантированно имеет методы Number
}
```
В таком случае мы можем использовать класс Number и его подклассы Integer…

Также можно использовать несколько ограничений, параметр типа может быть ограничен несколькими интерфейсами и одним классом, класс должен быть написан первым
```java
public class MyClass<T extends Number & Comparable<T>> {
    // T должен быть подклассом Number И реализовывать Comparable
}
```
Знаки подстановки(?) используются для повышения гибкости полезно когда метод работает с дженериками, но не зависит от конкретного типа, например, метод printList может печатать List<String>, List<Integer> и т.д.

public static void printList(List<?> list) { /* ... */ }

Верхняя граница знаков подстановки (<? Extends T>) означает любой тип который является классом T или его подклассом, позволяет читать элементы коллекции (но не записывать)
нижняя граница (<? super T>) любой тип класса Т или его суперкласса, позволяет записывать элементы в коллекцию, но при чтении будет возвращаться только Object 

###### Стирание типов

Во время компиляции: компилятор использует информацию о дженериках для проверки безопасности
Во время выполнения: в байт-коде вся информация о дженериках стирается. Все параметризованные типы заменяются на верхнюю границу (Object если граница не указана)

###### Последствия:

* Нельзя создать массив дженериков (T[10])
* Нельзя использовать instanceof с дженерик-типами (например, if (obj instanceof List<String>) не работает).
* Нельзя перегружать методы, если их сигнатуры отличаются только параметрами типов

## 37. Коллекции

Это унифицированная архитектура для предоставления об обработки групп объектов. Предоставляет набор интерфейсов и классов, которые позволяют эффективно хранить и обрабатывать данные.
Большинство коллекций не являются потокобезопасными, для этого нередко используют обертки
Все современные коллекцию используют дженерики для безопасности во время компиляции и устранения необходимости приведения
Интерфейс Collection расширяет Iterable это, позволяет использовать цикл for each

## 38. Иерархия коллекций

Она представлена двумя основными интерфейсами Collection и Map.
Collection делится на основные 3 ветви Set, List, Queue
* Set(множество) включает в себя: HachSet, LinkedHashSet
* List(список): LinkedList, ArrayList, Vector
* Queue(очередь): PriorityQueue, LinkedList

Map включает в себя hashMap, LinkedHashMap, Hashtable, TreeMap

## 39. List

List это из ключевых элементов коллекционного фреймворка, позволяющий хранить упорядоченные коллекции элементов, он расширяет интерфейс Collection, элементы хранятся в определенном порядке и к ним можно обращаться по индексу (начинается с нуля)

###### Основные реализации: 

1.	ArrayList основан на массиве, быстрый доступ по индексу
2.	LinkedList основан на связном списке, эффективен при частом удалении и вставке
3.	Vector устаревший, синхронизирован
4.	Stack расширяет vector, реализует стек
```java
      List<Integer> list = new ArrayList();
      //заполнение списка 3 элементами от 1 до 3
      list.add(1);
      list.add(2);
      list.add(3);
      //пример прохода по списку используя for-each, здесь вывод всех элементов в консоль
      for (Integer i:list){
      System.out.println(i);
      }
      boolean test= list.contains(2);// проверка содержит ли список этот элемент
      int index=list.indexOf(1); //получение индекса элемента по его значению
      int element=list.get(0); //получение элемента по его индексу
      list.remove(0);// удаление элемента по индексу
      System.out.println(Arrays.toString(list.toArray()));// вывод списка как строки
```
Как происходит добавление нового элемента:
* Проверка ёмкости: Когда вы вызываете add(), а внутренний массив ArrayList заполнен (т.е. size == capacity), его сначала необходимо увеличить.
* Расчёт новой ёмкости: ArrayList вычисляет новую ёмкость. Обычно эта новая ёмкость равна (oldCapacity * 3) / 2 + 1, что означает увеличение примерно на 50%. (Хотя «удвоение» — распространённая ментальная модель, и её часто используют, точный коэффициент увеличения в java.util.ArrayList обычно составляет 1,5 раза плюс один, хотя это особенность реализации, которая может меняться в разных версиях Java).
* Выделение нового массива: В памяти выделяется новый массив большего размера с вычисленной новой ёмкостью.
* Копирование элементов: Все элементы из старого внутреннего массива копируются в новый внутренний массив. Обычно это эффективно выполняется с помощью System.arraycopy().
* Обновление ссылок: Внутренняя ссылка ArrayList на старый (меньший) массив обновляется и теперь указывает на новый (больший) массив.
* Сборка мусора: Старый объект массива (не весь список, а только внутренний массив, содержащий элементы) становится доступным для сборки мусора, поскольку на него больше не указывают ссылки.
* Добавление элемента: Наконец, новый элемент добавляется в конец внутреннего массива с изменённым размером.
## 41. Set
Интерфейс Set это коллекция, содержащая уникальные элементы.

###### Основные характеристики
* Уникальность: при добавлении элемента идет проверка `equals()` и если элемент уже есть он просто не будет добавлен.
* Отсутствие индексации: так как у элементов нет порядка их нельзя получить по индексу
* Используется когда нужно быстро проверить на наличие элемента и когда требуется уникальность 

###### Ключевые реализации:
* HashSet это хештаблица, где порядок не гарантирован и самая высокая производительность.
* LinkedHashSet это хештаблица + связный список, соблюдается порядок вставки, немного медленнее hashset из-за  связного списка
* TreeSet это красно-черное дерево в котором элементы хранятся в отсортированном виде, O(logN) для основных операций

Процесс добавления нового элемента:

* Сначала вызывается hashCode(). HashSet использует hashCode() объекта, чтобы определить, в какой «группе» (или индексе) во внутреннем массиве должен находиться элемент. Это очень эффективный способ быстро сузить область возможного расположения элемента.
  Если несколько элементов могут оказаться в одной группе (из-за коллизий hashCode())
* Тогда и только тогда вызывается equals() для сравнения нового элемента с существующими элементами в этой конкретной группе. Если equals() возвращает true для любого существующего элемента, новый элемент считается дубликатом и не добавляется.
Для реализации уникальности, пользовательские объекты должны правильно реализовывали контракт equals-hashset
```java
Set<String> uniqueNames = new HashSet<>();

// Добавляем элементы
uniqueNames.add("Alice"); // true
uniqueNames.add("Bob");   // true
uniqueNames.add("Alice"); // false (дубликат, игнорируется)

// Проверяем размер
System.out.println(uniqueNames.size()); // Вывод: 2

// Итерация (порядок не гарантирован для HashSet)
for (String name : uniqueNames) {
    System.out.println(name);
}

//удаление объекта
uniqueNames.remove("Alice");
```

Объединение:эта операция объединяет все уникальные элементы из обоих множеств.
```java
Set<String> unionSet = new HashSet<>(setA); // Start with a copy of setA
unionSet.addAll(setB); 
```
Пересечение:эта операция приводит к созданию множества, содержащего только элементы, общие для обоих множеств.
```java
Set<String> intersectionSet = new HashSet<>(setA); // Start with a copy of setA
intersectionSet.retainAll(setB); 
```
Разность: эта операция приводит к созданию множества, содержащего элементы, которые есть в первом множестве (A), но отсутствуют во втором множестве (B).
```java
Set<String> differenceSet = new HashSet<>(setA); // Start with a copy of setA
differenceSet.removeAll(setB);
```
## 42. Map
Интерфейс Map представляет собой коллекцию, которая хранит данные в виде "ключ-значение", также ее еще называют словарем.

###### Основные характеристики:
* Хранит значение в виде "ключ-значение"
* Ключи в map должны быть уникальны, попытка добавить пару с таким же ключом просто заменит старое значение новым
* В Map могут быть дубликаты значений
* Главное преимущество Map заключается в быстром поиске, извлечении и обновления значения по ключу 

###### Ключевые реализации:
* HashMap хеш-таблица, порядок не гарантирован, не потокбезопасен, самый быстрый O(1) для операций `put()`, `get()`
* LinkedHashMap Хеш-таблица+ связный список, порядок вставки, O(1) для основных операций
* Treemap красно-черное дерево, сортировка по ключу, O(logN)

###### Основное Api:
* put(K key, V value) добавляет пару ключ-значение, если ключ уже есть обновляет значение и возвращает его
* get(Object key) возвращает значение по ключ, если ключ не найден, вернет null
* containsKey(Object key) проверяет содержит ли указанный ключ
* containsValue(Object value) проверяет содержит ли указанное значение
* remove(Object key) удаляет пару по указанному ключу и возвращает связанное с ним значение
* size() возвращает количество пар
* getOrDefault(Object key, V defaultValue)этот метод позволяет установить стандартное значение или значение по умолчанию. Он возвращает значение, с которым сопоставлен указанный ключ, или defaultValue, если карта не содержит сопоставления для ключа.

Поскольку map не является Collection, мы не можем использовать for-each для итераций используется специальные представления(Views)

###### Обход по ключам:
Получаем set всех ключей, что позволяет их перебирать 
```java
for (String key : map.keySet()) {
    System.out.println("Key: " + key + ", Value: " + map.get(key));
}
```

###### Обход по значению:

Получаем Collection всех значений 
```java
for (Integer value : map.values()) {
    System.out.println("Value: " + value);
}
```

###### Обход по парам:
Наиболее эффективный способ, так как избегает повторную проверку по ключам. Метод entrySet() возвращает Set<Map.Entry<K, V>>.
```java
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}
```

###### Контракт ключа
Для корректной работы HashMap и других очень важно чтобы ключи правильно реализовывали контракт hashCode-equals
## 43. Очередь(Queue)
Очередь это структура данных подобная очереди в магазине, она является подтипом Collection, поэтому реализует все методы.

#### Реализация:
* LinkedList — довольно стандартная реализация очереди. Элементы очереди хранятся в стандартной структуре данных связного списка. Это позволяет быстро добавлять элементы в конец (хвост) списка и удалять элементы из начала (головы) списка.
* PriorityQueue сохраняет свои элементы внутри в соответствии с их естественным порядком (если они реализуют Comparable), или в соответствии с Comparator переданным в PriorityQueue.
* Queue В большинстве Queue реализаций начало и конец очереди находятся на противоположных концах. Однако можно реализовать интерфейс Queue так, чтобы начало и конец очереди находились на одном конце. В этом случае получится стек.

```java
Queue<String> queue = new LinkedList<>();

queue.add("element 1");
queue.offer("element 2");

String element1 = queue.poll();

String element2 = queue.remove();
```
В этом примере мы создаем очередь и добавляем в очередь 2 элемента(метод add если очередь заполнена вернет исключение, а метод offer вернет false), после мы удаляем элементы, методы удаляют первый элемент очереди (poll если очередь пуста вернет null, а remove вернет исключение)
```java
String firstElement = queue.element();
```
Таким образом мы можем посмотреть первый элемент в очереди, метод element() если очередь пустая вернет исключение, также мы можем использовать метод peek(), он в этом случае вернет null.
* `queue.clear()` очистит всю очередь
* `queue.size()` получаем размер очереди
* `queue.contains("Mazda")` проверка содержит ли очередь элемент, если это так вернет true, иначе вернет false
```java
//перебор при помощи итератора
Iterator<String> iterator = queue.iterator();
while(iterator.hasNext(){
  String element = iterator.next();
}

//перебор при помощи for-each
for(String element : queue) {
    System.out.println(element);
}
```
## 44. Двусторонняя очередь(Deque)
Представляет собой двустороннюю очередь в которой можно добавлять и удалять элементы с двух сторон.

Реализация:
* LinkedList
* ArrayDeque
```java
// Array implementation of Deque
Deque<String> animal1 = new ArrayDeque<>();

// LinkedList implementation of Deque
Deque<String> animal2 = new LinkedList<>();
```
Поскольку Deque расширяет Queue интерфейс, он наследует все методы, но также имеет свои.
* addFirst() — добавляет указанный элемент в начало очереди. Вызывает исключение, если очередь заполнена.
* addLast() — добавляет указанный элемент в конец очереди. Вызывает исключение, если очередь заполнена.
* offerFirst() — добавляет указанный элемент в начало очереди. Возвращает значение, false если очередь заполнена.
* offerLast() — добавляет указанный элемент в конец очереди. Возвращает значение, false если очередь заполнена.
* getFirst() — возвращает первый элемент очереди. Вызывает исключение, если очередь пуста.
* getLast() — возвращает последний элемент очереди. Вызывает исключение, если очередь пуста.
* peekFirst() — возвращает первый элемент очереди. Возвращает, null если очередь пуста.
* peekLast() — возвращает последний элемент очереди. Возвращает, null если очередь пуста.
* removeFirst() — возвращает и удаляет первый элемент очереди. Вызывает исключение, если очередь пуста.
* removeLast() — возвращает и удаляет последний элемент очереди. Вызывает исключение, если очередь пуста.
* pollFirst() — возвращает и удаляет первый элемент очереди. Возвращает, null если очередь пуста.
* pollLast() — возвращает и удаляет последний элемент очереди. Возвращает, null если очередь пуста.
## 45. Stack
Стек это коллекция в которой элементы добавляются и удаляются в вершине.

Принцип называется(FILO) первым пришел, последний ушел(примером из жизни будет стопка тарелок, первую мы возьмем сверху, которую последнюю положили)

Создание стека
```java
Stack stack = new Stack();
Stack<String> stack = new Stack<String>();
```
Добавить элемент стэк
```java
stack.push("1");
```
Извлечение элемента из стека, после извлечения элемент удаляется из стека.
```java
Stack<String> stack = new Stack<String>();
stack.push("1");
String topElement = stack.pop();
```
Можно получить верхний элемента стека и после он останется в стеке
```java
String topElement = stack.peek();
```
Так можно получить индекс элемента в стеке,вершина имеет индекс "1"
```java
int index = stack.search("3");
```
Размер стека
```java
int size = stack.size();
```
Перебор элементов стека при помощи итератора:
```java
Stack<String> stack = new Stack<String>();

stack.push("123");
stack.push("456");
stack.push("789");

Iterator iterator = stack.iterator();
while(iterator.hasNext()){
    Object value = iterator.next();
}
```
При помощи streamAPI
```java
Stack<String> stack = new Stack<String>();
stack.push("A");
stack.push("B");
stack.push("C");

Stream stream = stack.stream();

stream.forEach((element) -> {
    System.out.println(element);  
});
```
При помощи стека можно перевернуть список
```java
List<String> list = new ArrayList<String>();
list.add("A");
list.add("B");
list.add("C");
System.out.println(list);

Stack<String> stack = new Stack<String>();
while(list.size() > 0) {
    stack.push(list.remove(0));
}

while(stack.size() > 0){
    list.add(stack.pop());
}

System.out.println(list);
```
Мы по одному элементу перемещаем их из списка в стек,а после из стека в список и за счет принципа FILO мы перевернем список

Можно использовать Deque в качестве стек
```java
Deque<String> dequeAsStack = new ArrayDeque>String>();

dequeAsStack.push("one");
dequeAsStack.push("two");
dequeAsStack.push("three");

String one   = dequeAsStack.pop();
String two   = dequeAsStack.pop();
String three = dequeAsStack.pop();
```
## 46. Iterator
Интерфейс Iterator это объект, который позволяет перебирать коллекцию по одному элементу за раз. 

Чтобы его использовать вы должны получить экземпляр итератора из коллекции объектов, он отслеживает элементы базовой коллекции, если изменить коллекцию во время перебора итератор это заметить и выбросит исключение при следующей попытке получить следующий элемент из итератора.

Основные методы:
* hasNext() возвращает true если итератор имеет еще элементы, иначе false
* next() возвращает следующий элемент из итератора
* remove() удаляет последний элемент возращенный методом next()
* forEachRemaining() выполняет итерацию по всем оставшимся элементам и вызывает лямбда-выражение в которое в качестве параметра передает оставшиеся элементы 

Получение итератора:
```java
List<String> list = new ArrayList<>();
list.add("one");
list.add("two");
list.add("three");

Iterator<String> iterator = list.iterator();


Set<String> set = new HashSet<>();
set.add("one");
set.add("two");
set.add("three");

Iterator<String> iterator2 = set.iterator();
```
Перебор при помощи итератора
```java
Iterator iterator = list.iterator();
while(iterator.hasNext()) {
    Object nextObject = iterator.next();
}
```
Порядок перебора зависит от какой коллекции получен итератор, итератор полученный от List будет перебирать в том порядке, в котором элементы хранятся в List, а вот от Set порядок не гарантирован

Удаление элементы при помощи remove() не вызывает исключение
```java
List<String> list = new ArrayList<>();

list.add("123");
list.add("456");
list.add("789");

Iterator<String> iterator = list.iterator();

while(iterator.hasNext()) {
    String value = iterator.next();

    if(value.equals("456")){
        iterator.remove();
    }
}
```

Пример использования forEachRemaining()
```java
List<String> list = new ArrayList<>();
list.add("Jane");
list.add("Heidi");
list.add("Hannah");

Iterator<String> iterator = list.iterator();
        
iterator.forEachRemaining((element) -> {
    System.out.println(element);
});
```
Также есть интерфейс ListIterator который позволяет перемещаться в две стороны
```java
List<String> list = new ArrayList<>();
list.add("Jane");
list.add("Heidi");
list.add("Hannah");

ListIterator<String> listIterator = list.listIterator();
        
while(listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
        
while(listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}
```
## 47. Временная сложность для разных операций разных коллекций
##### ArrayList
* `get(index)` O(1)
* `add(E e)` O(1)
* `add(index,E e)` O(N)
* `remove()index` O(N)
##### LinkedList
* `get(index)` O(N)
* `getFirst()`,`getLast()` O(1)
* `removeFirst()`,`removeLast()`O(1)
* `add(index,E e)` O(N)
##### HashSet
* `add(E e)`,`remove(Object)` O(1)
* `contains(Object o)` O(1)
##### LinkedHashSet
Все операции(add,remove,contains) O(1)
##### TreeSet
Все операции(add,remove,contains) O(logN)
##### HashMap
`put(K key,V value)`,`get(Object key)` O(1)
##### LinkedHashMap
Все операции(put,get) O(1)
##### TreMap
Все операции(put,get) O(logN)

O(1) не всегда O(1) так как зависит от хорошей реализации методов hashCode() equals, если будет большое количество коллизий, то придется обращаться к "корзине" при этом ложность может ухудшиться до O(N)для старых версий JAVA или O(logN) для Java 8+  

## 48. Неизменяемые коллекции(создание с помощью List.of(), методы класса Collections)
Неизменяемые коллекции это коллекции, которые не могут быть изменены после их создания.

Попытка добавить или изменить коллекцию приведет к генерации исключения.


В Java есть два основных способа создания таких коллекций: фабричные методы List.of() или старый метод использования оберток Collections 

##### Фабричные методы
Методы List.of(), Set.of(), Map.of() создают эффективные и неизменяемые экземпляры коллекций
* List.of() 
```java
List<String> list = List.of("A", "B", "C");
```
Создает неизменяемый список с сохранением порядка.
* Set.of()
```java
Set<Integer> set = Set.of(1, 2, 3);
```
Создает неизменяемое множество, порядок не гарантирован.
* Map.of()
```java
Map<K, V> map = Map.of("K1", 1, "K2", 2);
```
Создает неизменяемый словарь. Имеются перегруженные версии до 10 пар и Map.ofEntries() для большого числа 

##### Ключевые свойства:
* Неизменяемость
* Без null: запрещает хранить null
* Эффективность: более эффективны по скорости и памяти, чем их старые аналоги
```java
List<String> immutableList = List.of("Apple", "Banana");

try {
    immutableList.add("Cherry"); // Выбросит UnsupportedOperationException
} catch (UnsupportedOperationException e) {
    System.out.println("Изменение невозможно!");
}
```

##### Методы класса Collections
Эти методы это набор статических методов для работы с коллекциями, также есть методы, которые возвращает обертку-представление, которая блокирует мутации.

Основные методы-обертки:
* Collections.unmodifiableList(List list) возвращает неизменяемый список
* Collections.unmodifiableSet(Set set) возвращает неизменяемое множество
* Collections.unmodifiableMap(Map map) возвращает неизменяемый словарь
* Collections.unmodifiableCollection(Collection c) возвращает неизменяемое представление для общего интерфейса Collection

##### Разница между фабричными методами и методами Collections:
* Происхождение: фабричный метод создает новый объект, а метод коллекции возвращает неизменяемую обертку над существующей коллекцией
* Связь: фабричный метод полностью независим  от исходных данных, а метод коллекции зависим(изменение оригинала изменит и обертку)
* null:в фабричных методах он запрещен, а в методах Collections если есть в исходной коллекции
* Рекомендация:фабричные методы нужны для полностью гарантированной неизменяемости, а методы Collections полезны, чтобы защитить оригинал и предоставить доступ к данным
## 49. LinkedHashMap, TreeMap
##### LinkedHashMap
Это реализация Map и расширение HashMap, его особенность в том, что он сохраняет порядок вставки.

###### Он реализует два механизма:
* Хеш-таблица благодаря чему обладает высокой скорости доступа 
* Двусвязный список, что сохраняет порядок вставки и позволяет быстро обходить элементы в заданном порядке 

###### LinkedHashMap реализует 2 порядка:
* Порядок вставки это по умолчанию
* Порядок доступа: если словарь создан с параметром `accessOrder=true` его порядок меняется с каждым использованием put() или get(). Этот режим идеально подходит для реализации LRU-кеша.

##### TreeMap
Это реализация интерфейса SortedMap, его ключевая особенность, что он хранит пары в отсортированном порядке по ключу.

###### Механизм работы
TreeMap основан на структуре данных красно-черные дерево, которое является типом самобалансирующегося двоичного дерева поиска.
Оно гарантирует, что дерево остается сбалансированным и предотвращает деградацию в худшем случае до O(N).

###### Порядок элементов:
Порядок определяется ключами:
* Натуральный порядок: ключи сортируются в порядке, определяемом их естественным порядком
* Пользовательский порядок: Можно предоставить объект Comparator при создании TreeMap для собственной сортировки 

Сложность операций: все основные операции(put, get, remove, containsKey) имеют сложность O(logN)

###### Дополнительные возможности:
`firstKey()`,`lastKey()`
`ceilingKey()` наименьший ключ, больший или равный заданному
`floorKey()` наибольший ключ, меньше или равный заданному
`descendingMap()` возвращает обратное представление словаря
## 50. Интерфейсы Comparable и Comparator
##### Comparable
Интерфейс Comparable используется для натурального порядка объекта.

Местоположение: Должен быть реализован самим классом, объекты которого вы хотите сортировать.
Содержит единственный метод
```java
public int compareTo(T other);
```
* Возвращает отрицательное число если текущий объект меньше other
* Возвращает ноль если объекты равны
* Возвращает положительное число если текущий объект больше other
Лучше использовать когда существует единственный логически правильный способ сортировки (Integer по значению, String по алфавиту)
```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    // Сортировка по имени (естественный порядок)
    @Override
    public int compareTo(Person other) {
        return this.name.compareTo(other.name);
    }
}
```
Класс `Person` можно будет сортировать напрямую: `Collections.sort(listOfPeople);`

##### Comparator
Используется для пользовательского порядка или множестве альтернативных порядков.

Местоположение: реализуется в отдельном классе, который действует как внешний.

Содержит метод:
```java
public int compare(T obj1, T obj2);
```
Возвращает положительное, отрицательное число или ноль основываясь на сравнение `obj1`, `obj2`, также как compareTo().

Лучше использовать когда:
* Когда нужно реализовать несколько способов сортировки, например для `Person` по имени, возрасту, росту
* Когда вы не можете изменить исходный класс(классы сторонней библиотеки)
* Для сортировки объектов, которые не реализуют Comparable
```java
// Класс-компаратор для сортировки по возрасту
public class AgeComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return Integer.compare(p1.age, p2.age);
    }
}
```
## 51. Лямбда выражения, функциональные интерфейсы, Stream API

##### Лямбда-выражения

Лямбда-выражения это анонимные функции, без объявления имени, модификатора доступа и возвращающего значения.

Синтаксис:`(аргументы)->{тело}`.

Лямбда-выражения могут обращаться к переменным, но главное условие чтобы они были объявлены как final.Если локальная переменная никогда не переназначается после инициализации, компилятор считает её «фактически финальной», и вы можете использовать её в лямбда-выражении без явного объявления её как final. 

* Ссылка на статический метод: ClassName::staticMethodName
* Ссылка на метод экземпляра конкретного объекта: objectName::instanceMethodName
* Ссылка на метод экземпляра произвольного объекта определенного типа: ClassName::instanceMethodName
* Ссылка на конструктор: ClassName::new

Преимущества:
* Краткость и сокращение кода: устранение кода для анонимных классов
* Повышение читаемости: код более лаконичен и поведение выражено непосредственно в точке использования
* Поддержка функционального программирования: рассматривает код как данные и позволяют передавать функции в качестве аргументов 
* Интеграция StreamAPI: мощный способ обработки коллекций 
* Упрощенная параллельная обработка
* Улучшенный дизайн API
###### Структура лямбда-выражений:
* Могут иметь от нуля и более входных параметров
* Тип параметра можно указывать или он будет получен из контекста
* Параметры заключаются в круглые скобки и разделяются запятыми` (int a,int b)`, `(a,b)`
* Если параметров нет нужно использовать круглые скобки
* Если параметр один и его не нужно указывать явно, скобки опускаются a-> return a*a
* Если тело состоит из одного оператора его можно не заключать в фигурные скобки, а возвращаемое значение без оператора return. В противном случае нужно заключать блок кода в скобки, а в конце надо указывать возвращаемое значение со словом return, иначе возвращаемое значение будет void

Простой пример вывода всех элементов заданного массива. Заметьте, что есть более одного способа использования lambda-выражения. Ниже мы создаем lambda-выражение обычным способом, используя синтаксис стрелки, а также мы используем оператор двойного двоеточия (::), который в Java 8 конвертирует обычный метод в lambda-выражение:
```java
// Старый способ:
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
for(Integer n: list) {
    System.out.println(n);
}
```

```java
// Новый способ:
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
list.forEach(n -> System.out.println(n));
```

```java
// Новый способ с использованием оператора двойного двоеточия ::
list.forEach(System.out::println);
```
##### Функциональные интерфейсы 
Функциональным интерфейсом считается интерфейс который, имеет один нереализованный метод.
```java
@FunctionalInterface
public interface Converter<T, N> {
   N convert(T t);
}
```
Аннотация необходима, чтобы сообщить компилятору, что данный интерфейс функциональный и должен содержать не более одного метода.
```java
@FunctionalInterface
public interface Converter<T, N> {

   N convert(T t);

   static <T> boolean isNotNull(T t){
       return t != null;
   }

   default void writeToConsole(T t) {
       System.out.println("Текущий объект - " + t.toString());
   }

   boolean equals(Object obj);
}
```
Этот интерфейс все еще функциональный, так как статичные методы, методы по умолчанию и методы наследуемые от класса Object разрешены.

###### Базовые функциональные интерфейсы Java 8
Predicate базовый функциональный интерфейс для проверки соблюдения условия.
```java
Predicate<Integer> isEven = x -> x % 2 == 0;
System.out.println(isEven.test(4));
//вывод в консоль "true"
```

Consumer функциональный интерфейс, который принимает объект T, совершает какие-то действия и ничего не возвращает.
```java
Consumer<Integer> consumer = i -> System.out.println(++i+"test");
consumer.accept(1);
//вывод в консоль "2test"
```
Supplier не принимает никаких аргументов, но возвращает объект типа T
```java
Supplier<Integer> random = () -> {
            int value = list.get((int) (Math.random() * list.size()));
            return value;
};
System.out.println(random.get());
//вывод в консоль "4"
```
Function принимает аргумент типа T и приводит его к типу R и возвращает его 
```java
Function<String,Integer> converter = Integer::parseInt;
int test=converter.apply("1");
test++;
System.out.println(test);
System.out.println(converter.apply("123"));
//вывод в консоль 2 и 123
```
UnaryOperator интерфейс, который принимает объект типа T выполняет над ним операции и возвращает объект того же типа
```java
UnaryOperator<Integer> operator = x -> x * x;
System.out.println(operator.apply(2));
//вывод в консоль "4"
```
Это основные интерфейсы, остальные это усложненные их варианты
###### Функциональные интерфейсы в Stream
* Метод с predicate
Для примера возьмем метод класса stream filter, который принимает predicate, а возвращает stream только с теми элементами, которые подходят под условие predicate.
```java
List<Integer> evenNumbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8)
           .filter(x -> x % 2==0)
           .collect(Collectors.toList());
```
В итоге список evenNumbers будет состоять из элементов {2, 4, 6, 8}.
* Метод с Consumer
одним из методов будет peek
```java
List<String> peopleGreetings = Stream.of("Elena", "John", "Alex", "Jim", "Sara")
           .peek(x -> System.out.println("Hello " + x + " !!!"))
           .collect(Collectors.toList());
```
вывод в консоль выглядит так:
```java
Hello Elena !!!
Hello John !!!
Hello Alex !!!
Hello Jim !!!
Hello Sara !!!
```

* Метод с Supplier
Примером будет generate, который генерирует бесконечную последовательность на основе переданного ему функционального интерфейса.

```java
ArrayList<String> nameList = new ArrayList<>();
   nameList.add("Elena");
   nameList.add("John");
   nameList.add("Alex");
   nameList.add("Jim");
   nameList.add("Sara");

   Stream.generate(() -> {
       int value = (int) (Math.random() * nameList.size());
       return nameList.get(value);
   }).limit(5).forEach(System.out::println);
```
И вот какой мы получим вывод в консоль:
John
Elena
Elena
Elena
Jim
limit(5) необходим чтобы не было бесконечного вывода.
* Метод с Function
Типичный пример map который принимает элементы одного типа, что-то с ними делает и передает дальше,но уже могут быть элементы другого типа.
```java
List<Integer> values = Stream.of("32", "43", "74", "54", "3")
        .map(x -> Integer.valueOf(x)).collect(Collectors.toList());
```
Мы получим список чисел, но уже в формате Integer.
* Метод с UnaryOperator
В качестве примера возьмем iterate, он схож с iterate, но принимает 2 аргумента: первый, с которого начинается генерация последовательности, а второй UnaryOperator который указывает принцип генерации новых значений.
```java
Stream.iterate(9, x -> x * x)
           .limit(4)
           .forEach(System.out::println);
```
Вывод в консоль будет выглядить:
```java
9
81
6561
43046721
```


map() создаёт поток массивов (Stream<String[]>)

flatMap() превращает это в один плоский поток символов

```java
List<String> words = List.of("hello", "world");

List<String> letters = words.stream()
    .map(word -> word.split(""))           // Stream<String[]>
    .flatMap(Arrays::stream)               // Stream<String>
    .collect(Collectors.toList());

System.out.println(letters); // [h, e, l, l, o, w, o, r, l, d]
```
## 52. Аннотация
Аннотация это специальная структура, которая начинается с "@", прикрепляется к классам, методам, переменным, параметрам и другим элементам.
Примеры:
* @Override помечает переопределенный метод
* @RestController аннотация Spring Boot помечает класс как контроллер
Также можно создавать собственные аннотации
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
    String value();
}
```
* @Retention — указывает, когда аннотация доступна (SOURCE, CLASS, RUNTIME)
* @Target — указывает, к чему может применяться аннотация (CLASS, METHOD, FIELD и т.д.)

#### Обработка аннотаций
* Во время компиляции — аннотации могут использоваться для генерации кода (например, Lombok)
* Во время выполнения — через рефлексию можно получить доступ к аннотациям и изменить поведение программы

#### Использование
* Упрощают конфигурацию: вместо XML или JSON
* Повышают читаемость: код становится самодокументируемым
* Позволяют создавать гибкие фреймворки: например, Spring использует аннотации для внедрения зависимостей, REST-контроллеров и т.д.
```java
Method method = MyClass.class.getMethod("myMethod");
MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);
System.out.println(annotation.value());
```
с помощью рефлексии получить доступ к аннотации и извлечь её значение.

Основной недостаток использования рефлексии, в том числе для доступа к аннотациям, — снижение производительности
* Динамический поиск: При использовании рефлексии JVM приходится выполнять динамический поиск классов, методов, полей и аннотаций во время выполнения. Это включает поиск по структуре класса, что медленнее, чем прямое обращение к ним во время компиляции.
* Проверки безопасности: Рефлексия часто подразумевает обход стандартных правил доступа Java (например, доступ к закрытым членам). Диспетчер безопасности Java, если он активен, выполняет дополнительные проверки, что увеличивает накладные расходы.
* Отсутствие оптимизации во время компиляции: Компилятор Java и JVM могут применять множество оптимизаций к коду, использующему прямые вызовы методов или доступ к полям. Рефлексия обходит эти оптимизации, поскольку цели неизвестны до момента выполнения.
* Упаковка/Распаковка: рефлексивные вызовы часто подразумевают упаковку и распаковку примитивных типов, что также добавляет небольшие накладные расходы.
## 53. Модули
Модуль — это группа тесно связанных пакетов и ресурсов, а также новый файл-дескриптор модуля.

Каждый модуль отвечает за свои ресурсы, такие как медиа-файлы или файлы конфигурации.

При создании модуля мы включаем файл-дескриптор, который определяет несколько аспектов нашего нового модуля:

* Имя – имя нашего модуля
* Зависимости  – список других модулей, от которых зависит этот модуль.
* Публичные пакеты – список всех пакетов, которые мы хотим сделать доступными извне модуля.
* Предлагаемые услуги – мы можем предоставить реализации услуг, которые могут использоваться другими модулями.
* Потребляемые услуги – позволяет текущему модулю быть потребителем услуги.
* Разрешения на отражение — явно разрешает другим классам использовать отражение для доступа к закрытым членам пакета.

Типы модулей:
* Системные модули  — это модули, которые выводятся при запуске команды list-modules. Они включают модули Java SE и JDK.Эти модули делятся на четыре основные группы:  java, javafx, jdk  и  Oracle.
* Модули приложения – это то, что мы обычно хотим собрать, когда решаем использовать модули. Они названы и определены в скомпилированном  файле module-info.class, включённом в собранный JAR-архив.
* Автоматические модули – Мы можем включать неофициальные модули, добавляя существующие JAR-файлы в путь к модулям. Имя модуля будет получено из имени JAR-файла. Автоматические модули будут иметь полный доступ на чтение ко всем остальным модулям, загруженным по этому пути.
* Безымянный модуль  – когда класс или JAR-файл загружается в путь к классам, но не в путь к модулям, он автоматически добавляется в безымянный модуль. Это универсальный модуль для обеспечения обратной совместимости с ранее написанным кодом Java.

Чтобы настроить модуль, нам необходимо поместить в корень наших пакетов специальный файл с именем  module-info.java.
Этот файл называется дескриптором модуля и содержит все данные, необходимые для создания и использования нашего нового модуля.
```java
module myModuleName {
    // all directives are optional
}
```

```java
module my.module {
    requires module.name;
}
```
Теперь  my.module имеет  зависимость  от module.name как во время выполнения, так и во время компиляции.

```java
module my.module {
    requires static module.name;
}
```
Используя  директиву require static, мы создаём зависимость, действующую только во время компиляции
```java
module my.module {
    requires transitive module.name;
}
```
Теперь, когда разработчику требуется my.module, ему не придется также указывать  requires module.name, чтобы наш модуль все еще работал.

Мы используем  директиву exports, чтобы предоставить доступ ко всем публичным членам указанного пакета:
```java
module my.module {
    exports com.my.package.name;
}
```
Теперь, когда кто-то  потребует my.module, у него будет доступ к публичным типам в нашем  пакете com.my.package.name, но не к любому другому пакету.

Мы можем ограничить доступ модулей к нашим API с помощью  директивы exports…to.
Директива exports, мы объявляем пакет экспортируемым. Но мы также перечисляем модули, которым разрешено импортировать этот пакет, в директиве require. Как это выглядит:
```java
module my.module {
    export com.my.package.name to com.specific.package;
}
```

Мы обозначаем службы, которые использует наш модуль, с помощью  директивы uses.

Имя класса, которое мы  используем, — это либо интерфейс, либо абстрактный класс службы, а не класс реализации:
```java
module my.module {
    uses class.name;
}
```
Модуль также может быть  поставщиком услуг, который могут потреблять другие модули.

Первая часть директивы —  ключевое слово provide. Здесь указывается имя интерфейса или абстрактного класса.

Далее идет  директива with, в которой мы указываем имя класса реализации, который либо реализует интерфейс, либо  расширяет абстрактный класс.
```java
module my.module {
    provides MyInterface with MyInterfaceImpl;
}
```
Если нам необходимо разрешить отражение закрытых типов, но мы не хотим, чтобы весь наш код был раскрыт, мы можем использовать  директиву opens для раскрытия определенных пакетов.
```java
module my.module {
  opens com.my.package;
}
```
Мы можем выборочно открывать наши пакеты для заранее утверждённого списка модулей, в данном случае с помощью   директивы opens…to :
```java
module my.module {
    opens com.my.package to moduleOne, moduleTwo, etc.;
}
```
##### Путь к классам:
Это список каталогов и JAR-файлов.

Когда JVM ищет класс, она просматривает записи в пути к классам по порядку.

Все JAR-файлы и классы в пути к классам рассматриваются как часть безымянного модуля (о чём мы кратко упоминали ранее), что означает, что они могут свободно обращаться друг к другу и получать доступ ко всему, что экспортируется именованными модулями.
Он страдает от таких проблем, как «JAR-ад» (конфликт версий библиотек), и не обладает строгой инкапсуляцией.
#### Путь к модулям:
Это список каталогов, содержащих модули (обычно JAR-файлы, содержащие файл module-info.java).

Когда JVM ищет модуль, она ищет определения модулей в указанных каталогах.

Преимущества модулей в пути к модулю:
* Строгая инкапсуляция: только явно экспортированные пакеты видны другим модулям.
* Явные зависимости: модули должны указывать, какие другие модули им требуются.
* Надёжная конфигурация: JVM может при запуске проверять наличие всех необходимых модулей и разрешать зависимости.
* Никаких «JAR-адов» для модулей: каждый модуль имеет уникальное имя, и система предотвращает конфликты.
## 54. Optionals
Целью класса является предоставление решения на уровне типа для представления необязательных значений вместо  пустых ссылок.

Чтобы создать пустой объект Optional , нам просто нужно использовать его статический метод empty() :
```java
Optional<String> empty = Optional.empty();
```
Мы также можем создать необязательный объект с помощью статического метода  of() :
```java
String name = "test";
Optional<String> opt = Optional.of(name);
```
Однако аргумент, переданный методу of(), не может быть null. В противном случае мы получим исключение NullPointerException

Но если мы ожидаем некоторые значения NULL , мы можем использовать метод ofNullable() :
```java
Optional<String> opt = Optional.ofNullable(name);
```
При этом, если мы передадим пустую ссылку, исключение не возникнет, а вместо этого будет возвращен пустой необязательный объект

Когда у нас есть необязательный объект, возвращенный из метода или созданный нами, мы можем проверить, есть ли в нем значение, с помощью метода isPresent():
```java
Optional<String> opt = Optional.of("test");
opt.isPresent(); //true
opt = Optional.ofNullable(null); 
opt.isPresent(); //false
```
Кроме того, начиная с Java 11, мы можем сделать обратное с помощью  метода isEmpty:
```java
Optional<String> opt = Optional.of("test");
opt.isEmpty();//false
opt = Optional.ofNullable(null); 
opt.isEmpty();//true
```
Метод ifPresent() позволяет нам выполнить код для обёрнутого значения, если оно не равно null.
```java
Optional<String> opt = Optional.of("test");
opt.ifPresent(name -> System.out.println(name.length()));
```
Метод orElse() используется для извлечения значения, обёрнутого в экземпляр Optional. Он принимает один параметр, который служит значением по умолчанию. Метод orElse() возвращает обёрнутое значение, если оно присутствует, и его аргумент в противном случае:
```java
String nullName = null;
String name = Optional.ofNullable(nullName).orElse("john"); 
//name="john"
```
Метод orElseGet()  похож на orElse(). Однако вместо того, чтобы принимать значение, возвращаемое при отсутствии необязательного значения, он принимает функциональный интерфейс поставщика, который вызывается и возвращает значение вызова:
```java
String nullName = null;
String name = Optional.ofNullable(nullName).orElseGet(() -> "john");
    //name="john"
```
Разница между этими похожими методами в том, что если значение есть(не null) orElse() все равно выполниться, а orElseGet() нет.

Метод orElseThrow() вместо возврата значения по умолчанию при отсутствии упакованного значения он выдает исключение:
```java
String nullName = null;
    String name = Optional.ofNullable(nullName).orElseThrow(
      IllegalArgumentException::new);
```
В Java 10 появилась упрощённая версия метода orElseThrow() без аргументов . В случае пустого необязательного параметра он выдаёт исключение NoSuchElementException :
```java
String nullName = null;
String name = Optional.ofNullable(nullName).orElseThrow();
```
метод get():
```java
Optional<String> opt = Optional.of("test");
String name = opt.get();//name="test"
```
Однако, в отличие от предыдущих трех подходов, get() может возвращать значение только в том случае, если обернутый объект не равен null ; в противном случае он выдает исключение отсутствия такого элемента

Мы можем выполнить встроенную проверку нашего обёрнутого значения с помощью метода filter . Он принимает предикат в качестве аргумента и возвращает необязательный объект. Если обёрнутое значение проходит проверку предикатом, то необязательный объект возвращается как есть.
Однако если предикат возвращает false, то он вернет пустой Optional :
```java
Integer year = 2016;
Optional<Integer> yearOptional = Optional.of(year);
boolean is2016 = yearOptional.filter(y -> y == 2016).isPresent(); // true

boolean is2017 = yearOptional.filter(y -> y == 2017).isPresent(); // false
```
Использование map():
```java
List<String> companyNames = Arrays.asList(
      "paypal", "oracle", "", "microsoft", "", "apple");
    Optional<List<String>> listOptional = Optional.of(companyNames);

    int size = listOptional
      .map(List::size)
      .orElse(0); //6
```
В этом примере мы помещаем список строк в объект Optional и используем его метод map для выполнения действия над содержащимся в нём списком. В результате мы получаем размер списка.
Метод map возвращает результат вычисления, помещённый в Optional . Затем нам необходимо вызвать соответствующий метод для возвращённого Optional, чтобы получить его значение.

Как и метод map(), у нас есть альтернативный метод flatMap() для преобразования значений. Разница заключается в том, что map преобразует значения только после их распаковки, тогда как flatMap принимает распакованное значение и распаковывает его перед преобразованием.

Таким образом, при использовании метода map() необходимо добавить дополнительный вызов для извлечения значения перед использованием преобразованного значения. Таким образом, обёртка Optional будет удалена. Эта операция выполняется неявно при использовании flatMap.
В сочетании с тем фактом, что преобразование map() оборачивает результат в объект Optional , приводит к появлению вложенного Optional .

Метод or(): 

В Java 9 появился метод or(), который лениво возвращает другой необязательный параметр , если текущий необязательный параметр пуст. Если первый необязательный параметр имеет определённое значение, лямбда-функция, переданная методу or(), не будет вызвана, а значение не будет вычислено и возвращено:
```java
String expected = "properValue";

Optional<String> value = Optional.empty();
Optional<String> defaultValue = Optional.of("default");
Optional<String> result = value.or(() -> defaultValue);
System.out.println(result.get()); // "default"
value=Optional.of(expected);
result=value.or(() -> defaultValue);
System.out.println(result.get()); // "properValue"
```
Метод fPresentOrElse() позволяет передать Consumer если Optional определен, и Runnable если пуст, в данном примере у нас есть счетчики если Optional определен и если пуст, таким образом если он определен вызывается ` successCounter.incrementAndGet()`, а второй аргумент пропускается и также в обратной ситуации, если Optional пуст вызывается только второй аргумент.

```java
Optional<String> value = Optional.of("properValue");
AtomicInteger successCounter = new AtomicInteger(0);
AtomicInteger onEmptyOptionalCounter = new AtomicInteger(0);

value.ifPresentOrElse(
        v -> successCounter.incrementAndGet(),
        onEmptyOptionalCounter::incrementAndGet);
System.out.println(successCounter.get()); // 1
System.out.println(onEmptyOptionalCounter.get()); // 0
value=Optional.empty();
value.ifPresentOrElse(
        v -> successCounter.incrementAndGet(),
        onEmptyOptionalCounter::incrementAndGet);
System.out.println(successCounter.get()); // 1
System.out.println(onEmptyOptionalCounter.get()); // 1
```

Метод stream() позволяет обработать Optional как поток, что позволяет использовать все методы StreamAPI.

```java
Optional<String> value = Optional.of("qwerty");
List<String> collect = value.stream().map(String::toUpperCase).collect(Collectors.toList());
System.out.println(collect); //[QWERTY]
```
Если Optional пустой, то получится пустой поток, который не даст никакого эффекта.

Лучше не использовать:
* в полях класса
* в параметрах метода(лучше использовать перегрузку)
* когда значение гарантировано не нулевое
# **Модуль 2**
## 1.	Исключения
Исключения — это механизм обработки ошибок во время выполнения программы. Вместо того чтобы программа аварийно завершалась, Java позволяет перехватывать и обрабатывать ошибки.

Распространение исключений — это механизм, посредством которого исключение, будучи сгенерированным, перемещается по стеку вызовов до тех пор, пока не найдёт блок catch, способный его обработать. Если во всём стеке вызовов блок catch не найден, программа завершится.
## 2.	Иерархия исключений
Все исключения в Java — это объекты, унаследованные от класса Throwable.

Throwable
1. Error // Критические ошибки JVM (не обрабатываются)
2. Exception
* CheckedException  // Проверяемые (нужно обрабатывать)
* UncheckedException (RuntimeException) // Непроверяемые (можно не обрабатывать)

Проверяемые исключения (Checked)
Компилятор требует обработку (try-catch) или проброс (throws)
Примеры:
* IOException
* SQLException
* FileNotFoundException
```java
public void readFile(String path) throws IOException {
    BufferedReader reader = new BufferedReader(new FileReader(path));
    System.out.println(reader.readLine());
}
```
Непроверяемые исключения (Unchecked)
Наследуются от RuntimeException
Не требуют обязательной обработки
Примеры:
* NullPointerException
* ArrayIndexOutOfBoundsException
* IllegalArgumentException
```java
public void divide(int a, int b) {
    System.out.println(a / b); // может выбросить ArithmeticException
}

```
## 3.	Способы обработки исключений
```java
try {
    // код, который может выбросить исключение
} catch (IOException e) {
    // обработка исключения
} finally {
    // выполняется всегда (например, закрытие ресурсов)
}
```
Мы можем пробросить исключение выше
```java
public void connect() throws SQLException {
    // ...
}
```
Также мы можем создать свое собственное исключение
```java
public class InvalidUserInputException extends Exception {
    public InvalidUserInputException(String message) {
        super(message);
    }
}
```
* multi-catch: можно ловить несколько исключений в одном блоке

Технология multicatch появилась в Java 7 и позволяет одному блоку catch обрабатывать несколько типов исключений. Это помогает уменьшить дублирование кода, особенно когда логика обработки нескольких различных типов исключений одинакова или очень похожа.
Как это достигается:
Вы перечисляете типы исключений, разделяя их вертикальной чертой (|), в параметре блока catch.
* try-with-resources: автоматическое закрытие ресурсов (AutoCloseable)
* throw: используется для явного выбрасывания исключения
  
Ключевое слово throw:
* Назначение: Оно используется для явного создания исключения. Используя throw, вы сигнализируете о возникновении ошибки.
* Использование: Оно используется внутри тела метода.
* Аргумент: За ним должен следовать экземпляр Throwable (например, new IllegalArgumentException("Invalid input")).
* Эффект: Немедленно передаёт управление из текущего блока try в соответствующий блок catch или распространяет исключение по стеку вызовов, если в текущем методе не обнаружено catch.

Ключевое слово throws:

* Назначение: Используется в сигнатуре метода для объявления того, что метод может сгенерировать одно или несколько проверяемых исключений. Это способ сообщить компилятору (и другим разработчикам): «Если вы вызываете этот метод, учтите, что он может сгенерировать указанные исключения, и вам необходимо их обработать».
* Применение: Используется в сигнатуре метода после списка параметров.
* Аргумент: За ним следует список имён классов исключений, разделённый запятыми (например, IOException, SQLException).
* Эффект: Само исключение не генерируется; оно лишь информирует о том, что метод может его сгенерировать. Оно обязывает вызывающий код либо перехватить объявленные исключения, либо объявить их заново с помощью throws. Это в первую очередь относится к проверяемым исключениям. Непроверяемые исключения также могут быть объявлены, но это не обязательно.
## 4.	try с ресурсами
Это конструкция для безопасной работы с ресурсами, особенное файлами, потоками, соединениями. Она автоматически закрывает, когда блок завершил работу даже если произошло исключение.
Работает с объектами которые реализовывают интерфейс AutoCloseable или Closeable
```java
try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
    System.out.println(reader.readLine());
} catch (IOException e) {
    e.printStackTrace();
}
```
После завершения try-блока, reader.close() вызывается автоматически.
Если будет несколько ресурсов они закрываются в обратном порядке
```java
try (
    BufferedReader reader = new BufferedReader(new FileReader("input.txt"));
    BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))
) {
    String line;
    while ((line = reader.readLine()) != null) {
        writer.write(line);
        writer.newLine();
    }
}
```
Все ресурсы будут закрыты в обратном порядке: сначала writer, потом reader
## 5.	Ввод - вывод
Ввод вывод основан на потоках, они могут работать с консолью, сетью, файлами

Потоки делятся на байтовые и символьные.

Байтовые потоки считывают и записывают необработанные байты. Они изначально не «знают», что представляют эти байты. Символьные потоки, с другой стороны, предназначены для корректной обработки текстовых данных, абстрагируясь от сложностей кодировок символов.
Символьные потоки решают проблему кодировки, так как один символ "А" в одной кодировке может иметь один байт, а в другой несколько, и нам приходится вручную преобразовывать.

Буферизация важна так как снижает нагрузку, ускоряет вывод и ввод, делает работу с текстом удобнее, благодаря ей мы можем из файла читать по строчно, а не каждый символ, пример(BufferReader,BufferWriter)

Также потоки необходимо закрывать,если это не делать может привести к:
* Утечки ресурсов: при открытии потока файловая системы выделяет ресурс(файловый дескриптор или сокет) и она имеет ограничений на один процесс, что может привести к исключению "слишком много открытых файлов"
* Утечки памяти: если открыто слишком много потоков, они могут потреблять значительный объем памяти, снижая производительность или даже к исключению OutOfMemoryError
* Повреждение данных: данные потока могут быть буферизованы и не записаны в файл до его закрытия, если приложение аварийно завершит работу до закрытия потока наши данные могут быть поврeждены.
* Снижение производительности: так как ОС приходится управлять многими потоками

Концепция декоратор означает что мы можем обернуть один поток в другой для добавления новых функций или улучшить его поведение. Каждый поток декортаор принимает другой поток в своем конструкторе.

Плюсы такого подхода:
* Гибкость: позволяет комбинировать функциональность модульным способом
* Расширяемость: позволяет добавлять новые функции без изменения базового потока
* Разделение ответственности: например один поток прочитает байты, следующий добавит буферизацию, другой добавит чтение примитивных данных
* Повторное использование: BufferedInputStream может быть оболочкой для любого InputStream применяя везде буферизацию, где это необходимо.

если мы используем потоки с буферизацией, данные не сразу попадают в целевой ресурс, а метод flush() позволяет очистить буфер и немедленно записать данные в ресурс.
## 6.	Какие основные классы используются для работы с потоками ввода - вывода
Классы байтовые:
* Базовые: InputStream, OutputStream
* Файлы:FileInputStream, RandomAccessFile, FileOutputStream, RandomAccessFile
* Массивы:ByteArrayInputStream, ByteArrayOutputStream
* Буферизация: 	BufferedInputStream, BufferedOutputStream
* Фильтрация:FilterInputStream, FilterOutputStream
* Данные:DataInputStream,DataOutputStream
* Объекты:ObjectInputStream,ObjectOutputStream
Классы символьные:
* Базовые: Reader, InputStreamReader, Writer, OutputStreamWriter
* Файлы:FileReader,FileWriter
* Массивы:CharArrayReader, CharArrayWriter
* Буферизация:BufferedReader, BufferedWriter
* Строки:StringReader,StringWriter
## 7.	Основные правила во время работы с потоками ввода - вывода.
1. Всегда закрывать поток: close() или конструкция try-with-resource
2. Обрабатывать исключение:использовать try-catch или throws
3. Использовать буферизацию: ускоряет работу, а также уменьшает количество обращений к диску/сети
4. Если используется буферизация вызывать flush() для гарантированной записи, особенно при работе с сетью и файлами
5. Учитывать кодировку
6. Выбирать правильный тип потока: Байтовые для двоичных данных(изображение, аудио), Символьные для текстовых данных
7. Минимизировать количество открытых потоков
8. использование современного API будет эффективнее при работе с сетью и большим объемом данных
## 8.	Сериализация
Сериализация это процесс преобразования объекта в последовательность байтов, обратный процесс называется десериализация

Нужная для сохранения состояния объекта в файле или БД, передачи объекта по сети(в сокетах), кэширования объектов 

Чтобы ее использовать нужно реализовать интерфейс Serializable
```java
public class Person implements Serializable {
    private String name;
    private int age;
}
```

* ObjectOutputStream — записывает объект в поток.
* ObjectInputStream — читает объект из потока.
## 9. File operations
В Java имеется 2 основных API для работы с файлами java.io.File и java.nio.file.Path, второй может делать все что первый(старый, но не устарел), но больше и лучше
Отличия:
* Новые классы поддерживают символические ссылки, атрибуты файлов, поддержку метаданных, списки контроля доступа и многое другое.
* При удалении файла мы получим подробное исключение(файл отсутствует, заблокирован и т.д.), а не просто false
* Поддержка файловых систем в памяти

Создаем путь:
```java
Path path = Path.of("c:\\dev\\licenses\\windows\\readme.txt");
path = Path.of("c:/dev/licenses/windows/readme.txt");
path = Path.of("c:" , "dev", "licenses", "windows", "readme.txt");
path = Path.of("c:" , "dev", "licenses", "windows").resolve("readme.txt");
path = Path.of(new URI("file:///c:/dev/licenses/windows/readme.txt"));
```
Во всех случаях будет результат c:\dev\licenses\windows\readme.txt

Проверка существует ли файл
```java
boolean exists = Files.exists(path);
```
Дата последнего изменения:
```java
FileTime lastModifiedTime = Files.getLastModifiedTime(path);
```
Сравнение двух файлов:
```java
long mismatchIndex = Files.mismatch(path, Paths.get("c:\\dev\\whatever.txt"));
```
Возвращает позицию первого несовпадения, поэтому если будет два абсолютно разных файла, мы получим 0

Посмотреть владельца файла:
```java
UserPrincipal owner = Files.getOwner(path);
```
Получим запись вида: PROBOOK\DERELya (User)

Создание временных файлов:
```java
Path tempFile1 = Files.createTempFile("somePrefixOrNull", ".jpg");
Path tempFile2 = Files.createTempFile(path.getParent(), "somePrefixOrNull", ".jpg");

Path tmpDirectory = Files.createTempDirectory("prefix");
```
При создании временных файлов можно указать префикс (первый параметр) и суффикс (второй параметр). Оба параметра могут быть пустыми.

Префикс будет добавлен к имени временного файла, суффикс — это по сути расширение файла, и если его не указать, будет использоваться расширение по умолчанию «.tmp».

Файл будет создан в каталоге временных файлов по умолчанию.

Вместо временного каталога по умолчанию вы также можете указать свой собственный каталог, в котором будет создан временный файл.

Временные файлы не удаляются сами собой. Необходимо явно удалять их при создании в модульных тестах или при запуске в рабочей среде.

Создание файлов и директорий:
```java
Path newDirectory = Files.createDirectories(path.getParent().resolve("some/new/dir"));
Path newFile = Files.createFile(newDirectory.resolve("emptyFile.txt"));
```
Запись строк в файл:
```java
Files.writeString(utfFile, "this is my string");
Files.writeString(iso88591File, "this is my string", StandardCharsets.ISO_8859_1);
```
По умолчанию записывает в кодировке UTF-8,но ее можно изменить как во втором примере

Запись байтов:
```java
Files.write(anotherIso88591File, "this is my string".getBytes(StandardCharsets.ISO_8859_1));
```
использование Writers,OutputStreams:
```java
try (BufferedWriter bufferedWriter = Files.newBufferedWriter(utfFile)) {
    // handle reader
}

try (OutputStream os = Files.newOutputStream(utfFile)) {
    // handle outputstream
}
```

Чтение строк:
```java
String s = Files.readString(utfFile);
s = Files.readString(utfFile, StandardCharsets.ISO_8859_1);
```
Также по умолчанию использует UTF-8
```java
Files.readAllLines(Path path)
```
Чтение всех строк, он вернет список всех строк.
Чтение байтов:
```java
s = new String(Files.readAllBytes(utfFile), StandardCharsets.UTF_8);
```
Использование Readers,InputStreams^
```java
try (BufferedReader bufferedReader = Files.newBufferedReader(utfFile)) {
    // handle reader
}

try (InputStream is = Files.newInputStream(utfFile)) {
    // handle inputstream
}
```

Удаление папки(пустой):
```java
try {
    Files.delete(tmpDir);
} catch (DirectoryNotEmptyException e) {
    e.printStackTrace();
}
```
Получить список файлов в каталоге:
```java
try (var files = Files.list(tmpDirectory)) {
    files.forEach(System.out::println);
}

try (var files = Files.newDirectoryStream(tmpDirectory, "*.txt")) {
    files.forEach(System.out::println);
}
```
Выводит файлы на уровне каталога

Полный список файловлого дерева:
```java
try (var files = Files.walk(tmpDirectory)) {
    files.forEach(System.out::println);
}
```
## 10.	Сборщики проектов(Gradle, Maven)
## 11.	Этапы сборки в Maven
## 12.	Где на локальной машине хранятся скачанные зависимости
## 13.	Многопоточность
## 14. Способы создания потоков
## 15. Виды состояния потоков
## 16. Ключевое слово volatile
## 17. Внедрение зависимостей(Dependency injection)
DI — это, по сути, шаблон проектирования, позволяющий нам устранять жёстко заданные зависимости между объектами. Вместо того чтобы объект создавал свои зависимости или искал их, эти зависимости предоставляются ему.

Плюсы:
* Гибкость: Если реализация зависимости меняется, зависимый класс не нужно менять, пока интерфейс остаётся прежним.
* Тестируемость: Это позволяет легко создавать заглушки или фиктивные объекты для зависимостей во время модульного тестирования.
* Развязка: Объекты становятся менее зависимыми друг от друга, что приводит к более модульной и поддерживаемой кодовой базе.
* Повторное использование: Компоненты становятся более пригодными для повторного использования, поскольку они не привязаны к конкретным реализациям своих зависимостей.
* Упрощённая конфигурация: Особенно в таких фреймворках, как Spring, внедрение зависимостей упрощает конфигурацию сложных графов объектов.

Основные типы внедрения:
* Внедрение через конструктор: Зависимости передаются в качестве аргументов конструктору класса. Этот подход часто предпочтительнее, поскольку он гарантирует, что объект создан в допустимом состоянии (наличие всех необходимых зависимостей), и делает зависимости явными.
* Внедрение через сеттер (или внедрение через метод): Зависимости предоставляются через открытые методы-сеттеры после создания объекта. Это позволяет использовать необязательные зависимости или изменять зависимости после создания объекта.
* Внедрение через поле: Зависимости внедряются непосредственно в открытые или закрытые поля класса, обычно с помощью рефлексии. Это часто встречается в фреймворках, таких, как Spring Boot. Несмотря на удобство, без фреймворка это может усложнить тестирование и скрыть зависимости, что потенциально нарушает инкапсуляцию.

Контейнер IoC в Spring (например, ApplicationContext) играет ключевую роль во внедрении зависимостей (DI): он управляет жизненным циклом объектов (бинов), создает их, связывает между собой и предоставляет готовые экземпляры там, где они нужны, освобождая разработчика от ручного управления зависимостями.

При инверсии управления (Inversion of Control) мы меняем этот подход: объект больше не контролирует процесс создания и связывания зависимостей. Вместо этого внешний механизм (например, IoC-контейнер) берёт на себя управление.

Минусы: 
* Избыточная абстракция: можно создать слишком много интерфейсов и бинов, что усложнит проект.
* Трудность отладки: ошибки видны только во время запуска приложения
* Сложность конфигурации: при большом количестве зависимостей и бинов конфигурация может стать громоздкой
* Скрытая связанность: может усложнить понимание архитектуры 
* Циклические зависимости: может привести к тому, что бины зависят друг от друга, что вызывает ошибки и требует рефакторинга.
## 18. Проблемы многопоточных приложений: состояние гонки,  дедлоки и лайфлоки
## 19. Пакет java.util.concurrent
## 20. Atomic
## 21. Lock
## 22. Executors
## 23. Future, CompletableFuture
## 24. Синхронизаторы


Функция высшего порядка это функция которая либо принимает функцию в качестве параметра, либо возвращает функцию
```java
Collections.sort(list, (String a, String b) -> {
    return a.compareTo(b);
});
```
Они необходимы для более гибкого кода,также для работы с StreamAPI

Плюсы:
* Повторное использование кода
* Абстракция и модульность
* Читабельность: код может яснее показывать что он делает, а не то, как он это делает.
* Гибкость: поведение можно легко изменить, заменив переданную функцию.
