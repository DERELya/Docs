# **Модуль 1**

##    1.	**JVM, JRE, JDK**
Jvm это java virtul machine – виртуальная машина переводит байт-код в машинный, который после выполняется операционной системой именно благодаря этому достигается кроссплатформенность.
JRE(Java Runtime environment) это пакет, который предоставляет минимальную среду для выполнения Java приложений(JRE=JVM+библиотеки).
JDK(Java development kit) это полный набор инструментов для разработки, компиляции, отладки и запуска Java приложений. Состоит из JRE и инструментов разработки.
Инструменты разработки:
   1.	Компилятор, который переводит java код в байткод (файлы java в class)
   2.	Java application launcher запускает приложения используя JVM и JRE
   3.	Java debugger отладчик для поиска ошибок
   4.	Генерация документации
      5.	Jar для создания и управления jar архивами 

##    2.	**Области памяти в java**

Память, которую использует JVM разбита на 5 основных областей:
   1.	Куча(Heap)это область памяти которая доступная каждому потоку(глобальная память) хранит все объекты и массивы(созданные при помощи слова new). Память в куче контролируется сборщиком мусора
   2.	Стек (stack) используется для выполнения потоков(у каждого потока свой стек), порядок в стеке работает по принципу последним пришел, первым ушел(Last in First out LIFO) это делает выделения и освобождение памяти очень быстрым. Стек хранит фреймы в фрейме хранятся локальные переменные, параметры(аргументы) метода, частичные вычисления и точка возврата(куда нужна вернуться после завершения метода) фрейм создается при каждом вызове метода и уничтожается по завершению.
   3.	Область методов хранит структуру всех загруженных классов и интерфейсов, информацию о полях и методах, статические переменные и пул констант времени выполнения. Эта область доступна для каждого потока
   4.	Регистр счетчик программы хранит адрес на следующую инструкцию байт-кода для текущего потока. Каждый поток имеет свой собственный регистр PC(program counter) 
   5.	Стек нативных методов хранит нужен для возможности использовать нативные методы. Каждый поток имеет свой нативный стек

##   3.	**Class Loaders. Виды, для чего нужны**

Это механизм загрузки классов, который позволяет динамически загружать классы в память когда они необходимы, а не все сразу. Загрузчики создают пространство имен для каждого класса это позволяет использовать несколько версий одного класса, также они отделяют пользовательские классы от системных. Существует 3 основных загрузчика классов:
      1. Bootstrap самый первый и родительский, загружает основные библиотеки JAVA, является частью JVM, написанный на нативном коде
      2. Extension(загрузчик расширений) дочерний по отношению к bootstrap и загружает классы из $JAVA_HOME/jre/lib/ext/ для дополнительных возможностей 
      3. Системный загружает классы специфичные для вашего приложения, он ищет классы в Class path
      4. Пользовательские. Пользователи сами могут создать загрузчик наследуя от класса ClassLoader позволяет загружать классы из нестандартных мест например из сети, бд, зашифрованных jar

## 4.Объект класса Class

 Объект Class это описание самого типа, какие поля содержит, методы, конструкторы, интерфейсы, супер класс, пакет, аннотации 
Получить объект Class можно при помощи:
1.	
```java
.class <String> stringClass = String.class;
```
2.	через метод getClass()
```java
String s = "Hello";
 Class<?> objectClass = s.getClass();
```
3.	через статический метод forName()
```java
Class<?> classObj = Class.forName("java.util.HashMap");
```

Метод Class	Описание
getName()	Возвращает полное имя класса (с пакетом).
getSimpleName()	Возвращает имя класса без имени пакета.
getSuperclass()	Возвращает объект Class суперкласса.
getInterfaces()	Возвращает массив объектов Class реализованных интерфейсов.
getFields(), getMethods(), getConstructors()	Возвращают массивы объектов Field, Method и Constructor (публичные).
getDeclaredFields(), getDeclaredMethods(), getDeclaredConstructors()	Возвращают все объявленные элементы, включая приватные.
newInstance() (устарел) или getDeclaredConstructor().newInstance()	Создает новый экземпляр этого класса.

## 5. Классы и объекты

Класс это описание сущности: какие поля должна содержать, какие методы реализованы.
Объект это экземпляр класса который обладает своим состоянием и своими значениями.
Интерфейс это набор методов класса доступные для использования.
Пример: человек это класс у него есть рост, вес, возраст, имя, пол, а вот конкретный человек Саша,29,180,90,мужчина это объект(экземпляр класса) и он умеет рисовать, читать, писать это как раз интерфейс
```java

class Car {// Поля (состояние/атрибуты)
    String model;
    String color;
    int speed;

    // Методы (поведение)
    void startEngine() {
        // Логика запуска двигателя
    }

    void accelerate(int increase) {
        speed += increase;
    }}
Объект
Car car1 = new Car(); // Объект 1

// Объект 1: имеет свое уникальное состояние
car1.model = "Toyota";
car1.color = "Red";
car1.speed = 0;
```
## 6. Структура класса

Структура класса состоит из:
1.	Модификатора доступа (откуда будет виден класс) обычно это public виден в любом месте
2.	Ключевого слова Class обязательное для определения
3.	Название класса с заглавной буквы(Person)
4.	Наследование (extends) указывает на родительский класс 
5.	Интерфейсы (implements) указывается какие интерфейсы класс должен реализовать
Пример:
```java
public class ClassName extends SuperClass implements Interface1, Interface2 {
    // Тело класса
}
```

Класс может содержать поля, методы и вложенные классы

## 7. Поля

Поля это данные которые содержит сущность например у класса человек есть поля возраст, рост, имя 

## 8. Конструкторы(ключевое слово super и this)

Конструктор это метод которые вызывается при создании экземпляра класса, их может быть несколько, его задача инициализация, задать начальные значения полям объекта. У него нет возвращаемого типа данных и если вы не напишите сами конструктор, будет использоваться конструктор по умолчанию.
Ключевое слово this ссылается на текущий экземпляр класса внутри которого оно используется.
Пример:
```java
public Car(String color) {// 'color' справа — это параметр метода
    // 'this.color' слева — это поле экземпляра класса
    this.color = color;}
```
Можно использовать для вызова другого конструктора this(…)
Слово super используется для доступа к членам родительского класса, конструкторы не наследуются и первым инструкцией в теле должно быть super(…) таким образом вызывается родительский конструктор.
Пример:
```java
class Vehicle {  
    String type;
    public Vehicle(String type) {     
        this.type = type;    }
}

class Car extends Vehicle {
    int doors;

    public Car(String type, int doors) {
        super(type); // ⬅️ Вызывает конструктор Vehicle(String)
        this.doors = doors;
    }
}
```
Также можно вызывать методы родителя и получать доступ к полям.

## 9. Методы(сигнатура методов, перегрузка методов)

Сигнатура метода включает в себя имя и список аргументов (!!!возвращаемый тип данных и модификатор доступа не входит в сигнатуру метода)
public void say(String message)
Сигнатура здесь будет say(string)
Перегрузка метода это возможность использовать несколько методов с одинаковым именем, но разными сигнатурами. Это достигается изменением сигнатуры: разный порядок параметров (если типы отличаются), разный тип параметров, разное количество параметров.
Перегрузка (Overloading) происходит в одном классе, это механизм полиморфизма
Перегрузка — это когда в одном классе есть несколько методов с одинаковым именем, но разными параметрами.
## 10. Статические и нестатические блоки инициализации

Нестатические блоки инициализации — это блоки кода заключенные в фигурные скобки «{}» внутри класса и до конструктора, выполняется каждый раз при создании нового экземпляра класса при помощи new, 
пример:
```java
public class NonStaticDemo {    private int counter;
    
    // Нестатический блок инициализации
    {
        counter = 1;
        System.out.println("Нестатический блок выполнен. Counter: " + counter);
    }
    
    public NonStaticDemo() {
        System.out.println("Конструктор выполнен.");
    }
    }
   ```
Статические блоки инициализации вызываются один раз для загрузки в JVM при первом создании экземпляра класса или при первом доступе к статическому полю и заключены в фигурные скобки «{}» но перед блоком еще нужно ключевое слово static, выполняется до конструкторов и до любых нестатических блоков
Пример:
```java
public class StaticDemo {    private static int loadCount;

    // Статический блок инициализации
    static {
        loadCount = 0;
        System.out.println("Статический блок выполнен. Класс загружен.");
    }
    
    public StaticDemo() {
        loadCount++;
        System.out.println("Объект создан. Общее количество: " + loadCount);
    }
}
```

## 11. Модификаторы

Модификаторы — это ключевые слова, которые добавляются к определению классов, полей, методов, конструкторов. Они делятся на модификаторы доступа, которые определяют уровень видимости и модификаторы не доступа они определяют другие характеристики не связанные с уровнем видимости

## 12. static, final, abstract

**Static** говорит о том что поле или метод принадлежит классу, а не конкретному объекту, для всех объектов существует только она копия статического поля.

**Final** запрещает наследование, переопределение и изменение 
Для классов значит что запрещено наследование.
Для полей это значит что поле будет константой(значение присвоено один раз)
Для методов что он не может быть переопределен в подклассах.

**Abstract** используется для создания абстрактных структур(шаблонов)
Для класса нельзя создать объект этого класса, он может содержать абстрактные методы.
Для метода не пишется реализация, а только объявляется и подкласс обязан его реализовать.

## 13. private, protected, public, package private

Private виден только в классе
Protected виден только том же классе, подклассах, в том же пакете
Public виден везде
Package private ставится по умолчанию, виден только в том же пакете

## 14. Варианты установки значений свойств объектов

Варианты делятся на два основных этапа: инициализация (пи создании объекта) и изменение(после создания)
1. через конструктор 
```java
public class Book {
    private String title;
    
    // Конструктор
    public Book(String title) {
        this.title = title; // Установка значения через параметр
    }
} 
```
2. нестатический блок инициализации
```java
public class Box {
    private int volume;
    // Блок инициализации
    {
        this.volume = 100; // Установка значения по умолчанию
    }
   ```
3. прямая инициализация 
```java
public class Person {
    private String species = "Human"; // Прямая инициализация
    private int age = 0;
}
```
4. при помощи сеттера 
```java
public class Person {
    private int age;
//сеттер для возраста	
public void setAge(int age){
	this.age=age;
    }
}
```
5. прямой доступ к полю
```java
public class Person {
    public int age;
}
Person person=new Person();
person.age=10;

```
## 15. Поля, конструктор, сеттеры(плюсы, минусы каждого)

Поля это переменная в классе, изменение ее через прямой доступ(самый быстрый и простой синтаксис из минусов это нарушение инкапсуляции, невозможно валидировать данные, изменение имени поля приводит к тому что нужно менять везде где используется)
Конструктор +:гарантирует что объект создается валидным и  полным, обеспечивает неизменяемость если поля final
Минусы: 
1. при большом количестве полей конструктор может быть большим
2. Не позволяет изменять поля
3. Требует перегрузки для набора разных параметров 
Сеттеры

###### Плюсы:

* Позволяет проводить валидацию.
* Позволяет изменять поля после его создания.
* Обеспечивает инкапсуляцию.

###### Минусы:

Не всегда нужен если объект final 

## 16. Абстрактные классы и интерфейсы(отличия, где что лучше использовать)
Абстрактный класс это класс который служит шаблоном, он может иметь частичную реализацию(базовый код),обычно от него наследуют другие классы,а он имеет поля и методы которые необходимы всем наследникам. У него тесная связь("является") например Animal(абстрактный класс) и класс наследник Cat, мы можем утверждать, что кот является животным и он будет иметь поля животного, методы нужно переопределить в наследнике. Мы не можем создать объект абстрактного класса, но мы можем сделать так:
```java
Animal a = new Dog(); // допустимо
a.makeSound();        // вызов метода Dog
```
Пример абстрактного класс:
```java
public abstract class Vehicle{
    public int numPassengers;
    public double weight;
    public double fuel;
    public double maxSpeed;
    public int numWheels;
    public double speed;

    public abstract void startMoving();
    public void StopMoving(Vehicle vehicle){
        vehicle.speed=0;
        vehicle.fuel=this.fuel;
    }
}
```

Интерфейс это набор абстрактных методов,которые класс обязуется реализовать.
Пример:
```java
public interface Drivable {
    void accelerate();
    void brake();
}
```
Для использования интерфейсов необходимо ключевое слово `implements` 
```java
public class Car implements Drivable {
    public void accelerate() {
        System.out.println("Car speeds up");
    }

    public void brake() {
        System.out.println("Car slows down");
    }
}
```
Интерфейсы могут наследовать другие интерфейсы и тогда он включает все методы интерфейса родителя, значит класс должен будет реализовать все методы (потомка и родителя).
default метод в интерфейсе — это действительно стандартная реализация, которую можно использовать по умолчанию, если класс не переопределяет её.
static метод в интерфейсе принадлежит самому интерфейсу, а не объекту, и вызывается по имени интерфейса и его нельзя переопределить.
Нельзя создать объект типа интерфейса, можно так:
```java
Drivable d = new Car(); // ✅ Car реализует Drivable
d.accelerate();
```
##### Отличия:

1. классы могут наследовать только один абстрактный класс, но при этом могут реализовывать множество интерфейсов
2.  в абстрактном классе может быть частичная реализация, когда как интерфейс полностью абстрактный.
3.  в абстрактном классе могут быть любые поля, а в интерфейсе только public static final константы 
4.  в абстрактном классе есть конструктор, в интерфейсе нет
5.  связь при использовании абстрактного класса тесная иерархия, используя интерфейсы будет контрактная связь («может делать»)

##### Когда что использовать:

###### Абстрактные классы:

1. когда требуется тесная связь(Animal->cat,dog)
2. общий код(базовая реализация)
3. для хранения состояния 

###### Интерфейсы:

1. для определения контракта
2. множественное поведение например: пингвин может плавать и есть 
3. отделить определение от реализации
4. гибкость другие разработчики смогут добавлять реализацию контракта  не будучи ограниченными иерархией

## 17. Изменяемые и неизменяемые объекты(примеры неизменяемых классов в java, как сделать класс неизменяемым)

Неизменяемые объекты(immutable) — это объекты состояние которых нельзя изменить, любая операция, которая должна изменить объект, на самом деле возвращает новый объект, а исходный остался нетронутым.
Плюсы:
Потокобезопасность так как объект неизменяемый не нужно заботиться о синхронизации
Простота кэширования такой объект можно легко кэшировать и его хеш-код вычислять один раз
Идеально подходят для ключей, так как хеш код не меняется (HashMap, HachSet)
Примеры: String, классы обертки (Integer, Double, Boolean, Character), BigDecimal, BidInteger, классы дат и времени LocalDate, LocalTime, ZonedTimeZone и т.д.
Изменяемые (mutable) объект может изменяться после его создания.
Примеры:
StringBuilder, StringBuffer для работы со строками
Большинство коллекций HashMap,ArrayList.

##### Чтобы сделать класс неизменяемым нужно:

1. его объявить с использованием final(это предотвращает наследование так как подкласс мог бы переопределить методы) 
2. все поля private final чтобы private скрывает поля, final делает их неизменяемыми
3.  отсутствие методов сетторов чтобы нельзя было изменить поля класса
4.  инициализировать поля в конструкторе, гарантирует, что объект будет инициализирован в момент создания 
5.  глубокое копирование изменяемых полей
Если класс имеет ссылку на изменяемый объект,мы должны избежать его изменения и делать копирование:
В конструкторе не сохранять прямую ссылку, вместо этого сохранять копию
В геттере возвращать копию объекта
Пример:
```java
import java.util.Date;

public final class ImmutableStudent { // 1. Класс final
    
    private final int id;             // 2. Поля private final
    private final String name;        // 2. Поля private final
    private final Date birthDate;     // 2. Поле - ссылка на изменяемый объект Date

    // 4. Инициализация только в конструкторе
    public ImmutableStudent(int id, String name, Date birthDate) {
        this.id = id;
        this.name = name;
        // 5a. Глубокое копирование: сохраняем копию Date
        this.birthDate = new Date(birthDate.getTime());
    }
    
    // 3. Нет сеттеров
    
    // Геттеры
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Date getBirthDate() {
        // 5b. Глубокое копирование: возвращаем копию Date
        return new Date(this.birthDate.getTime());
    }
}   
```
## 18. Inner и Nested классы

Вложенные классы (Nested) — это класс, объявленный внутри другого класса, они бывают двух видов: Статические вложенные (static nested class) и внутренние класс (inner class) 
Статический вложенный класс объявляется со словом static. Он не имеет доступ к нестатическим полям и методам внешнего класса, только к статическим, создается при помощи имени внешнего класса даже без создания его экземпляра.
Внутренний класс — это нестатический вложенный класс
Он всегда связан с конкретным экземпляром внешнего класса и имеет полный доступ к его полям и методам (даже private) 

## 19. Локальные и анонимные классы

Локальный это класс, объявленный внутри метода или другого блока
* Виден только внутри метода или блока, где инициализирован
* Имеет доступ ко всем полям внешнего класса, потому что связан с экземпляром класса
* Нельзя использовать private, public, protected
Пример:
```java
public class Outer {
    void display() {
        int limit = 100; // Эффективно final
        
        class LocalPrinter { // ⬅️ Локальный класс
            public void print() {
                System.out.println("Limit from method: " + limit); // Доступ к 'limit'
            }
        }
        
        LocalPrinter lp = new LocalPrinter();
        lp.print();
    }
}
```
Анонимный класс — это класс, который не имеет имени, используется для создания объекта, чтобы реализовать интерфейс или абстрактный/конкретный класс
 Выражение new InterfaceName/ClassName() {... } создает и немедленно возвращает единственный экземпляр анонимного класса.
Нельзя создать второй экземпляр такого класса
Не может объявлять конструктор так как не имеет имени 
Пример:
```java
interface Greeting {
    String greet();
}

public class AnonDemo {
    public void executeGreeting() {
        // ⬅️ Анонимный класс, реализующий интерфейс Greeting
        Greeting spanishGreeting = new Greeting() { 
            @Override
            public String greet() {
                return "Hola!";
            }
        }; 
        System.out.println(spanishGreeting.greet());
    }
}
```
	Сейчас обычно используется лямбда-выражение 

## 20. Класс Object

Это корень иерархии всех классов в Java, все классы явно или неявно наследуются от класса Object. Это означает что каждый объект наследует методы Object.

## 21. Методы класса Object

1.	`Equals(obj)` используется для сравнения на логического равенство двух объектов по умолчанию сравнивает по ссылке(указывают ли на один объект в памяти), почти всегда необходимо переопределять для того, чтобы сравнивать на основе их состояния.
2.	`hachCode()` используется чтобы вернуть хеш-код объекта для эффективного хранения и поиска объектов в хеш-коллекциях(HashSet, HashMap), если вы переопределили equals(), вы обязаны и переопределить и hashCode(если объекты равны по equals, то они обязаны иметь один хеш-код)
3.	`toString()` создает и возвращает копию объекта, обычно возвращает имя класса и после знака @ хеш-код, обычно переопределяется чтобы получать полезную и читаемую информацию
4.	`clone()` создает и возвращает копию объекта, требуется чтобы класс реализовал интерфейс Cloneable(который является маркерным и интерфейсом, не имеющий  методов), выполняет поверхностное копирование
5.	`wait(), notify(),notifyAll()` используются для межпоточного взаимодействия, должны вызываться только внутри синхронизированного блока или метода так как работают с блокировкой объекта
Класс Object так важен, потому что от него наследуются все классы и любой объект может быть обработан как Object.
Любая коллекция может хранить любой тип, потому что ее методы add(Object e) работают с общим родительским  типом. Это основа для обобщенного программирования в Java.

## 22. Контракт equals – hashcode

Контракт это набор правил которые должны быть выполнены для переопределния методов equals(), hashcode()
1.	Согласованность если объекты равны по equals, то и хеш-коды должны быть одинаковыми
2.	Если два хеш-кода равны это не гарантирует, что они равны по equals, это называется коллизией хеш-кодов. Хеш-код используется для быстрого поиска, а equals для окончательной проверки
3.	Если информация, используемая в сравнении equals не изменилась, то многократный вызов hashCode() должен возвращать один и тот же хеш-код
Нарушение правил ведет к не предсказуемому поведению, например изменение хеша после его помещения в таблицу придет к тому, что объект потеряется в памяти и его нельзя будет получить по ключу, но он будет занимать память
Рекомендации: 
	Использовать одни и те же поля в equals() и hashCode(), для неизменяемых объектов хранит хеш-код в final поле

## 23. Метод clone

Clone() создает и возвращает копию объекта, для его использования класс должен реализовывать интерфейс Cloneable, так как clone() в Object объявлен protected, мы должны переопределить его с модификатором public чтобы могли использовать вне класса.
Есть два типа копирования:
1.	Поверхностное копирование оно копирует значения примитивных полей и ссылок на объекты, это приводит к тому, что если у одного клона изменить значение вложенного объекта он измениться во всех клонах
2.	Глубокое копирование требует ручной реализации, вызывается super.clone() для поверхностного копирования, для всех изменяемых ссылочных типов создается и присваиваются новые экземпляры, в результате клонированный объект полностью независим от оригинала.
Пример глубокого копирования:
```java
@Override
    public Object clone() throws CloneNotSupportedException {
        // 1. Поверхностное копирование: создается новый объект Person и копируются поля name и ссылка address
        Person clonedPerson = (Person) super.clone();
        
        // 2. Глубокое копирование: создается новая копия объекта Address
        // Это предотвращает совместное использование Address оригиналом и клоном.
        clonedPerson.address = (Address) this.address.clone();
        
        return clonedPerson;
    }
   ```
Как альтернатива можно использовать конструктор копирования где мы просто копируем поля экземпляра.

Пример:
```java
public Person(Person other) {
    this.name = other.name;
    this.address = new Address(other.address.getCity()); // Вручную создаем копию Address
}
```
## 24. Принципы ООП

1.	Инкапсуляция — это сокрытия методов и полей от пользователя
2.	Полиморфизм позволяет нам использовать объекты с одинкавоыми интерфейсами без знаний структуры и типа объекта.
3.	Наследование позволяет нам наследовать поля и методы от класса родителя
4.	Абстракция позволяет нам выделить общие характеристики и методы в один класс, а после наследоваться от него
 
## 25. Наследование и Ассоциация (определение, плюсы-минусы каждого)

Наследование  механизм, при котором один класс получает свойства и методы другого класса(отношение «является») например dog является animal, родитель animal и дочерний класс dog.

###### Плюсы:

* Повторное использование кода, так как дочерний класс имеет доступ к полям и методам родителя
* Полиморфизм позволяет использовать объект дочернего класса где ожидается родительский
* Создает четкую иерархию классов

###### Минусы:

* Тесная связь: любое изменение в классе родителе отразиться на дочернем, кроме добавления методов
* Java поддерживает только одиночное наследование
* Нарушение инкапсуляции, так как раскрываем детали реализации родителя

Ассоциация — это общее понятие, описывающее структурную связь между двумя или более классами (отношение «имеет»), реализуется через композицию или агрегацию, класс содержит ссылку на другой класс в виде поля, это позволяет использовать функциональность другого объекта.
В композиции отношение «часть-целое» где часть не может существовать без целого, при уничтожении целого уничтожается и часть
В агрегации отношение такое же, но часть может существовать без целого 

###### Плюсы:

* Классы слабо зависят друг от друга, что упрощает изменения
* Гибкость: позволяет легко изменять какой объект использовать (можно заменить объект на другой)
* Инкапсуляция: внутренние детали ассоциированного объекта скрыты

###### Минусы:

* Требуется ручное написание кода для делегированного вызова ассоциированному объекту
* Для реализации сложных отношений может потребоваться написать больше кода чем при простом наследовании
###### Сравнение ассоциации и наследования:

* Отношение: в наследовании это «является» в ассоциации это включение («имеет»)
* Связанность: в наследовании тесная, в ассоциации слабая
* Принцип ООП: полиморфизм, повторное использование кода в наследовании и инкапсуляция, делегирование в ассоциации 

## 26. Переопределение методов

Переопределение методов — это механизм Java позволяющий дочернему классу предоставлять собственную реализацию метода, который определен в родительском классе

###### Правила переопределения:
1.	Сигнатура метода должна сохраняться (такая же, как в родительском классе)
2.	Метод должен быть определен в родительском классе и дочерний должен его наследовать
3.	Переопределенный метод не может иметь более ограничивающий модификатор доступа чем в суперклассе, например если в родителе protected, то у потомка protected или public 
4.	Переопределенный метод не должен объявлять новые исключения, он может использовать меньше чем в родителе или подклассы исключений
5.	Методы, объявленные как private, static, final не могут быть переопределены 

Рекомендуется использовать аннотацию @override так компилятор поймет, что вы переопределяете метод и выдаст ошибку в случае ошибки в сигнатуре 
Благодаря этому реализуется динамическая диспетчеризация: JVM решает какой метод вызвать во время выполнения, а не компиляции основываясь на фактическом типе объекта, на который ссылается переменная например:
```java
Animal myAnimal = new Dog(); // Ссылка типа Animal, объект типа Dog
myAnimal.makeSound(); // Вызовет Dog.makeSound() -> "Dog barks."
// Если бы не было переопределения, был бы вызван метод Animal. 
```
## 27. Статическое и динамическое связывание

Связывание — это процесс сопоставления вызова метода с его конкретной реализацией. В Java оно может быть статическим (во время компиляции) и динамическим ( во время выполнения)  
Статическое связывание происходит во время компиляции, компилятор выбирает реализацию на основе типа ссылки.

###### Когда происходит:

1.	Статические методы, потому что они принадлежат классу 
2.	Final методы они не могут быть переопределены 
3.	Private методы они не наследуются и не могут быть переопределены
4.	Поля: доступ к полям всегда происходит статически
5.	Перегрузка методов: компилятор выбирает на основе типов аргументов во время компиляции
Динамическое связывание происходит во время выполнения JVM определяет какой метод вызвать на основе фактического типа объекта, на который ссылается переменная, происходит обычно с переопределенными методами

## 28. Оболочки примитивных типов. Основное API. Особенности сравнения значений.

Оболочки примитивных типов это классы которые предоставляют объектный эквивалент для каждого примитивного типа(int->Integer, Boolean->Boolean, chra->Charactet)
Автоупаковка и автораспаковка это автоматический процесс преобразование примитивного типа в его объектную оболочку и наоборот

###### Основное API:
1.	Методы преобразования эти методы используются для преобразования строки в примитивный тип (parseInt(String s)) 
2.	Методы получения значений каждый класс-оболочка имеет метод для получения своего значения в виде примитивов (intValue())
3.	Методы преобразования в объект: эти методы используется для преобразования примитивов или строк в объект оболочку, они могут использовать кеш valueOf(int i) , valueOf(String s)
4.	Большинство числовых оболочек предоставляют константы Integer.MAX_VALUE , Double.NEGATIVE_INFINITY

###### Особенности сравнения значений 
1.	Оператор сравнения «==» сравнивает ссылки двух объектов 
```java


Integer a = 100;
Integer b = 100;
System.out.println(a == b); // true

Integer c = 500;
Integer d = 500;
System.out.println(c == d); // false
```
Большинство классов оболочек (кроме Double и Float) кэшируют данные в диапазоне -128 до 127
2.	Для логического сравнения необходимо использовать equals()
3.	Смешанное сравнение (примитив и оболочка), при таком сравнении оболочка автоматически распаковывается до примитива.


## 29. String

String это неизменяемый класс, который содержит последовательность символов. String неизменяемый это значит что при любом действие которое казалось бы изменяет строку, на самом деле создает новый объект. Это обеспечивает потокобезопасность и также позволяет использовать пул строк.

## 30. String pool

Пул строк — это специальная область в памяти(куче) для литералов.
Если мы создаем строку литералом
 `String s = "Hello";`
То вначале JVM проверяет пул на наличии такого литерала и если он есть возвращает ссылку на существующий объект в памяти, если же нет, то создает его и возвращает ссылку. Когда мы создаем строку при помощи new всегда создается новая строка в куче (вне пула) даже если строка там есть.
При помощи метода `intern()` мы можем строку переместить из кучи в пул, если такая строка уже есть в пуле, мы вернем ссылку на объект.

## 31. API

* `equals(Object other)` Сравнивает содержимое строк (регистрозависимо).
* `equalsIgnoreCase(String other)` Сравнивает содержимое строк (без учета регистра).
* `compareTo(String other)` Сравнивает строки лексикографически (используется для сортировки).
* `indexOf(char/String)`	Возвращает индекс первого вхождения символа/подстроки.
* `contains(CharSequence s)`	Проверяет, содержит ли строка указанную последовательность.
* `substring(int begin, int end)`	Возвращает новую строку — подстроку.
* `replace(char old, char new)`	Возвращает новую строку с заменой символов.
* `trim()`	Возвращает новую строку, удаляя начальные и конечные пробелы.
* `length()`	Возвращает длину строки.
* `charAt(int index)`	Возвращает символ по указанному индексу.
* `toUpperCase(), toLowerCase()`	Возвращает новую строку в верхнем/нижнем регистре.
* `split(String regex)`	Разбивает строку на массив строк по заданному разделителю (регулярному выражению).

## 32. StringBuilder, StringBuffer

Эти классы используются для работы с изменяемыми строками, они позволяют изменять объект, что делает их более эффективными для сложных манипуляций.

StringBuilder в основном используется когда работа происходит в одном потоке, так как он быстрее, но не синхронизированный

StringBuffer является потокобезопасным, он медленнее из-за использования блокировок, все его публичные методы синхронизированы, значит что только один поток может изменять в данный момент времени.

###### Основные методы:

* `append(...)`	Добавляет строку, примитив или символ в конец последовательности.
* `insert(int offset, ...)`	Вставляет строку или другой тип данных в последовательность по указанному индексу.
* `delete(int start, int end)`	Удаляет символы в указанном диапазоне.
* `reverse()`	Изменяет последовательность символов на обратную.
* `capacity()`	Возвращает текущую емкость (выделенное место в памяти).
* `toString()`	Преобразует изменяемую последовательность обратно в неизменяемый объект String (этот метод создает новый объект String). 

## 33. Алгоритмы

Алгоритм — это последовательность инструкций или правил для решения какой-либо задачи или получения результата
Основные характеристики:
1.	Дискретность алгоритм должен завершаться через конечное число шагов
2.	Определенность каждая инструкция должна быть четкой и не иметь двойного толкования
3.	Вход алгоритм должен принимать ноль или больше аргументов
4.	Выход алгоритм должен производить один или более результатов (решения задачи)
5.	Эффективность каждая операция должна быть простой чтобы ее можно было выполнить за конечное время

###### Анализ сложности алгоритмов:

1.	Временная сложность описывает время выполнения алгоритма, зависящее от размера входных данных.
2.	Пространственная сложность описывает какой объем памяти требуется для выполнения алгоритма, растет с увеличением размера входных данных. 

## 34. Big O notation(какие виды временной сложности алгоритмов бывают)

Для формального описания сложности используется O-нотация, она описывает асимптотическую сложность алгоритма(то как он себя ведет при больших входных данных)

* O(1) Постоянная (Доступ к элементу массива по индексу).
* O(log N) Логарифмическая (Бинарный поиск.)
* O(N) Линейная (Поиск максимального элемента в несортированном массиве.)
* O(N log N)} Линеарифмическая (Эффективные алгоритмы сортировки (Merge Sort, Heap Sort).)
* O(N^2) Квадратичная (Простые алгоритмы сортировки (Bubble Sort, Insertion Sort).)
* O(2^N) Экспоненциальная (Решение задачи коммивояжера методом грубой силы.)


## 35. Виды сортировок(отличие quicksort от merge sort)

###### 1.	Простые

Подходят для небольших наборов данных, медленные на больших массивах(сортировка пузырьком, сортировка выбором, сортировка вставками ) 

###### 2.	Эффективные

Стандарт для сортировки больших массивов(Сортировка слиянием, быстрая сортировка, пирамидальная сортировка)

###### Отличия quicksort mergeSort:

Это два эффективных алгоритма сортировки, основанные на принципе «разделяй и властвуй» 
* Средняя сложность: у них одинаковая O(N log N)
* Сложность наихудшая: у быстрой O(N^2), а у слиянием O(N log N)
* Быстрая сортировка нестабильная, а слиянием стабильная
* Подход: у быстрой сортировки разделение сложное, слияние простое, вся работа будет на этапе разделения. У сортировки слиянием разделение простое, а слияние сложное, массив делится пополам, и вся работа делается на этапе слияния двух отсортированных подмассивов
* Память: у быстрой O(log N) или O(N) для рекурсии, для сортировки слиянием всегда требуется O(N) 
* Рекурсия: Быстрая сортировка использует хвостовую рекурсию, а сортировка слиянием не хвостовую

Быстрая сортировка быстрее благодаря лучшему использованию кеша процессора, но может сломаться на плохо выбранных данных(уже отсортированный массив)
Сортировка слиянием более надежная, используется когда нужна стабильность и память не играет ключевую роль

## 36. Generics

Дженерики это мощная функция которая позволяет создавать классы, методы и интерфейсы, работающие с различными типами данных.
Назначение: 
1.	Безопасность типов: дженерики гарантируют что в коллекцию или метод будет помещен объект ожидаемого типа.
2.	Устранение приведения: при получение объекта из коллекции не нужно явно приводить объект
3.	Повторное использование кода: один класс дженерик можно использовать для разных типов  

###### Ключевые понятия:

1.	Параметризованные типа:
T(type) общий заполнитель для любого типа
E(element) используется для элементов коллекций
K(key) V(value) используется для пар ключ значение 
2.	Дженерик класс
```java
// Класс, который может хранить объект любого типа T
public class Box<T> {
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}

// Использование
Box<Integer> integerBox = new Box<>();
integerBox.set(10);
Integer x = integerBox.get();
```
3.	Дженерик метод
Параметризированный метод, который можеть быть объявлен как в обычном классе, так и в классе-дженерике
```java
// Параметр типа <T> объявляется перед типом возвращаемого значения
public static <T> void printArray(T[] array) {
    for (T element : array) {
        System.out.println(element);
    }
}
```

###### Ограничение типов

По умолчанию любой дженерик может быть заменен любым не примитивом, ограничения позволяют указать что Т должен быть подклассом определенного класса или реализовывать определенный интерфейс.

Ограничения через extends используются для ограничения верхней границы
```java
public class NumericBox<T extends Number> {
    // Теперь T гарантированно имеет методы Number
}
```
В таком случае мы можем использовать класс Number и его подклассы Integer…

Также можно использовать несколько ограничений параметр типа может быть ограничен несколькими интерфейсами и одним классом, класс должен быть написан первым
```java
public class MyClass<T extends Number & Comparable<T>> {
    // T должен быть подклассом Number И реализовывать Comparable
}
```
Знаки подстановки(?) используются для повышения гибкости полезно когда метод работает с дженериками, но не зависит от конкретного типа, например, метод printList может печатать List<String>, List<Integer> и т.д.

public static void printList(List<?> list) { /* ... */ }

Верхняя граница знаков подстановки (<? Extends T>) означает любой тип который является классом T или его подклассом, позволяет читать элементы коллекции (но не записывать)
нижняя граница (<? super T>) любой тип класса Т или его суперкласса, позволяет записывать элементы в коллекцию, но при чтении будет возвращаться только Object 

###### Стирание типов

Во время компиляции: компилятор использует информацию о дженериках для проверки безопасности
Во время выполнения: в байт-коде вся информация о дженериках стирается. Все параметризованные типы заменяются на верхнюю границу (Object если граница не указана)

###### Последствия:

* Нельзя создать массив дженериков (T[10])
* Нельзя использовать instanceof с дженерик-типами (например, if (obj instanceof List<String>) не работает).
* Нельзя перегружать методы, если их сигнатуры отличаются только параметрами типов

## 37. Коллекции

Это унифицированная архитектура для предоставления об обработки групп объектов. Предоставляет набор интерфейсов и классов, которые позволяют эффективно хранить и обрабатывать данные.
Большинство коллекций не являются потокобезопасными, для этого нередко используют обертки
Все современные коллекцию используют дженерики для безопасности во время компиляции и устранения необходимости приведения
Интерфейс Collection расширяет Iterable это позволяет использовать цикл for each

## 38. Иерархия коллекций

Она представлена двумя основными интерфейсами Collection и Map.
Collection делится на основные 3 ветви Set, List, Queue
* Set(множество) включает в себя:HachSet, LinkedHashSet
* List(список): LinkedList, ArrayList, Vector
* Queue(очередь): PriorityQueue, LinkedList

Map включает в себя hashMap, LinkedHashMap, Hashtable, TreeMap

## 39. List

List это из ключевых элементов коллекционного фреймворка, позволяющий хранить упорядоченные коллекции элементов, он расширяет интерфейс Collection, элементы хранятся в определенном порядке и к ним можно обращаться по индексу (начинается с нуля)

###### Основные реализации: 

1.	ArrayList основан на массиве, быстрый доступ по индексу
2.	LinkedList основан на связном списке, эффективен при частом удалении и вставке
3.	Vector устаревший, синхронизирован
4.	Stack расширяет vector, реализует стек
```java
      List<Integer> list = new ArrayList();
      //заполнение списка 3 элементами от 1 до 3
      list.add(1);
      list.add(2);
      list.add(3);
      //пример прохода по списку используя for-each, здесь вывод всех элементов в консоль
      for (Integer i:list){
      System.out.println(i);
      }
      boolean test= list.contains(2);// проверка содержит ли список этот элемент
      int index=list.indexOf(1); //получение индекса элемента по его значению
      int element=list.get(0); //получение элемента по его индексу
      list.remove(0);// удаление элемента по индексу
      System.out.println(Arrays.toString(list.toArray()));// вывод списка как строки
```

## 41. Set
Интерфейс Set это коллекция, содержащая уникальные элементы.

###### Основные характеристики
* Уникальность: при добавлении элемента идет проверка `equals()` и если элемент уже есть он просто не будет добавлен.
* Отсутствие индексации: так как у элементов нет порядка их нельзя получить по индексу
* Используется когда нужно быстро проверить на наличие элемента и когда требуется уникальность 

###### Ключевые реализации:
* HashSet это хештаблица, где порядок не гарантирован и самая высокая производительность.
* LinkedHashSet это хештаблица + связный список, соблюдается порядок вставки, немного медленнее hashset из-за  связного списка
* TreeSet это красно-черное дерево в котором элементы хранятся в отсортированном виде, O(logN) для основных операций

Для реализации уникальности, пользовательские объекты должны правильно реализовывали контракт equals-hashset
```java
Set<String> uniqueNames = new HashSet<>();

// Добавляем элементы
uniqueNames.add("Alice"); // true
uniqueNames.add("Bob");   // true
uniqueNames.add("Alice"); // false (дубликат, игнорируется)

// Проверяем размер
System.out.println(uniqueNames.size()); // Вывод: 2

// Итерация (порядок не гарантирован для HashSet)
for (String name : uniqueNames) {
    System.out.println(name);
}

//удаление объекта
uniqueNames.remove("Alice");
```

## 42. Map
Интерфейс Map представляет собой коллекцию, которая хранит данные в виде "ключ-значение", также ее еще называют словарем.

###### Основные характеристики:
* Хранит значение в виде "ключ-значение"
* Ключи в map должны быть уникальны, попытка добавить пару с таким же ключом просто заменит старое значение новым
* В Map могут быть дубликаты значений
* Главное преимущество Map заключается в быстром поиске, извлечении и обновления значения по ключу 

###### Ключевые реализации:
* HashMap хеш-таблица, порядок не гарантирован, не потокбезопасен, самый быстрый O(1) для операций `put()`, `get()`
* LinkedHashMap Хеш-таблица+ связный список, порядок вставки, O(1) для основных операций
* Treemap красно-черное дерево, сортировка по ключу, O(logN)

###### Основное Api:
* put(K key,V value) добавляет пару ключ-значение, если ключ уже есть обновляет значение и возвращает его
* get(Object key) возвращает значение по ключ, если ключ не найден,вернет null
* containsKey(Object key) проверяет содержит ли указанный ключ
* containsValue(Object value) проверяет содержит ли указанное значение
* remove(Object key) удаляет пару по указанному ключу и возвращает связанное с ним значение
* size() возвращает количество пар

Поскольку map не является Collection, мы не можем использовать for-each для итераций используется специальные представления(Views)

###### Обход по ключам:
Получаем set всех ключей, что позволяет их перебирать 
```java
for (String key : map.keySet()) {
    System.out.println("Key: " + key + ", Value: " + map.get(key));
}
```

###### Обход по значению:

Получаем Collection всез значений 
```java
for (Integer value : map.values()) {
    System.out.println("Value: " + value);
}
```

###### Обход по парам:
Наиболее эффективный способ, так как избегает повторную проверку по ключам.Метод entrySet() возвращает Set<Map.Entry<K, V>>.
```java
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}
```

###### Контракт ключа
Для корректной работы HashMap и других очень важно чтобы ключи правильно реализовывали контракт hashCode-equals
## 43. Временная сложность для разных операций разных коллекций
##### ArrayList
* `get(index)` O(1)
* `add(E e)` O(1)
* `add(index,E e)` O(N)
* `remove()index` O(N)
##### LinkedList
* `get(index)` O(N)
* `getFirst()`,`getLast()` O(1)
* `removeFirst()`,`removeLast()`O(1)
* `add(index,E e)` O(N)
##### HashSet
* `add(E e)`,`remove(Object)` O(1)
* `contains(Object o)` O(1)
##### LinkedHashSet
Все операции(add,remove,contains) O(1)
##### TreeSet
Все операции(add,remove,contains) O(logN)
##### HashMap
`put(K key,V value)`,`get(Object key)` O(1)
##### LinkedHashMap
Все операции(put,get) O(1)
##### TreMap
Все операции(put,get) O(logN)

O(1) не всегда O(1) так как зависит от хорошей реализации методов hashCode() equals, если будет большое количество коллизий, то придется обращаться к "корзине" при этом ложность может ухудшиться до O(N)для старых версий JAVA или O(logN) для Java 8+  

## 44. Неизменяемые коллекции(создание с помощью List.of(), методы класса Collections)
Неизменяемые коллекции это коллекции, которые не могут быть изменены после их создания. Попытка добавить или изменить коллекцию приведет к генерации исключения.
В Java есть два основных способа создания таких коллекций: фабричные методы List.of() или старый метод использования оберток Collections 

##### Фабричные методы
Методы List.of(), Set.of(), Map.of() создают эффективные и неизменяемые экземпляры коллекций
* List.of() 
```java
List<String> list = List.of("A", "B", "C");
```
Создает неизменяемый список с сохранением порядка.
* Set.of()
```java
Set<Integer> set = Set.of(1, 2, 3);
```
Создает неизменяемое множество, порядок не гарантирован.
* Map.of()
```java
Map<K, V> map = Map.of("K1", 1, "K2", 2);
```
Создает неизменяемый словарь. Имеются перегруженные версии до 10 пар и Map.ofEntries() для большого числа 

##### Ключевые свойства:
* Неизменяемость
* Без null: запрещает хранить null
* Эффективность: более эффективны по скорости и памяти, чем их старые аналоги
```java
List<String> immutableList = List.of("Apple", "Banana");

try {
    immutableList.add("Cherry"); // ❌ Выбросит UnsupportedOperationException
} catch (UnsupportedOperationException e) {
    System.out.println("Изменение невозможно!");
}
```

##### Методы класса Collections
Эти методы это набор статических методов для работы с коллекциями, также есть методы, которые возвращает обертку-представление, которая блокирует мутации.

Основные методы-обертки:
* Collections.unmodifiableList(List list) возвращает неизменяемый список
* Collections.unmodifiableSet(Set set) возвращает неизменяемое множество
* Collections.unmodifiableMap(Map map) возвращает неизменяемый словарь
* Collections.unmodifiableCollection(Collection c) возвращает неизменяемое представление для общего интерфейса Collection

##### Разница между фабричными методами и методами Collections:
* Происхождение: фабричный метод создает новый объект, а метод коллекции возвращает неизменяемую обертку над существующей коллекцией
* Связь: фабричный метод полностью независим  от исходных данных, а метод коллекции зависим(изменение оригинала изменит и обертку)
* null:в фабричных методах он запрещен, а в методах Collections если есть в исходной коллекции
* Рекомендация:фабричные методы нужны для полностью гарантированной неизменяемости, а методы Collections полезны, чтобы защитить оригинал и предоставить доступ к данным
## 45. LinkedHashMap, TreeMap
##### LinkedHashMap
Это реализация Map и расширение HashMap, его особенность в том, что он сохраняет порядок вставки.

###### Он реализует два механизма:
* Хеш-таблица благодаря чему обладает высокой скорости доступа 
* Двусвязный список, что сохраняет порядок вставки и позволяет быстро обходить элементы в заданном порядке 

###### LinkedHashMap реализует 2 порядка:
* Порядок вставки это по умолчанию
* Порядок доступа: если словарь создан с параметром `accessOrder=true` его порядок меняется с каждым использованием put() или get(). Этот режим идеально подходит для реализации LRU-кеша.

##### TreeMap
Это реализация интерфейса SortedMap, его ключевая особенность, что он хранит пары в отсортированном порядке по ключу.

###### Механизм работы
TreeMap основан на структуре данных красно-черные дерево, которое является типом самобалансирующегося двоичного дерева поиска.
Оно гарантирует, что дерево остается сбалансированным и предотвращает деградацию в худшем случае до O(N).

###### Порядок элементов:
Порядок определяется ключами:
* Натуральный порядок: ключи сортируются в порядке, определяемом их естественным порядком
* Пользовательский порядок: Можно предоставить объект Comparator при создании TreeMap для собственной сортировки 

Сложность операций: все основные операции(put, get, remove, containsKey) имеют сложность O(logN)

###### Дополнительные возможности:
`firstKey()`,`lastKey()`
`ceilingKey()` наименьший ключ, больший или равный заданному
`floorKey()` наибольший ключ, меньше или равный заданному
`descendingMap()` возвращает обратное представление словаря
## 46. Интерфейсы Comparable и Comparator
##### Comparable
Интерфейс Comparable используется для натурального порядка объекта.

Местоположение: Должен быть реализован самим классом, объекты которого вы хотите сортировать.
Содержит единственный метод
```java
public int compareTo(T other);
```
* Возвращает отрицательное число если текущий объект меньше other
* Возвращает ноль если объекты равны
* Возвращает положительное число если текущий объект больше other
Лучше использовать когда существует единственный логически правильный способ сортировки (Integer по значению, String по алфавиту)
```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    // Сортировка по имени (естественный порядок)
    @Override
    public int compareTo(Person other) {
        return this.name.compareTo(other.name);
    }
}
```
Класс `Person` можно будет сортировать напрямую: `Collections.sort(listOfPeople);`

##### Comparator
Используется для пользовательского порядка или множестве альтернативных порядков.

Местоположение: реализуется в отдельном классе, который действует как внешний.

Содержит метод:
```java
public int compare(T obj1, T obj2);
```
возвращает положительное, отрицательное число или ноль основываясь на сравнение `obj1`, `obj2`, также как compareTo().

Лучше использовать когда:
* Когда нужно реализовать несколько способов сортировки, например для `Person` по имени, возрасту, росту
* Когда вы не можете изменить исходный класс(классы сторонней библиотеки)
* Для сортировки объектов, которые не реализуют Comparable
```java
// Класс-компаратор для сортировки по возрасту
public class AgeComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return Integer.compare(p1.age, p2.age);
    }
}
```
## 47. Лямбда выражения, функциональные интерфейсы, Stream API

##### Лямбда-выражения

Лямбда-выражения это анонимные функции, без объявления имени, модификатора доступа и возвращающего значения.
Синтаксис: `(аргументы)->{тело}`

###### Структура лямбда-выражений:
* Могут иметь от нуля и более входных параметров
* Тип параметра можно указывать или он будет получен из контекста
* Параметры заключаются в круглые скобки и разделяются запятыми` (int a,int b)`, `(a,b)`
* Если параметров нет нужно использовать круглые скобки
* Если параметр один и его не нужно указывать явно, скобки опускаются a-> return a*a
* Если тело состоит из одного оператора его можно не заключать в фигурные скобки, а возвращаемое значение без оператора return. В противном случае нужно заключать блок кода в скобки, а в конце надо указывать возвращаемое значение со словом return, иначе возвращаемое значение будет void

Простой пример вывода всех элементов заданного массива. Заметьте, что есть более одного способа использования lambda-выражения. Ниже мы создаем lambda-выражение обычным способом, используя синтаксис стрелки, а также мы используем оператор двойного двоеточия (::), который в Java 8 конвертирует обычный метод в lambda-выражение:
```java
// Старый способ:
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
for(Integer n: list) {
    System.out.println(n);
}
```

```java
// Новый способ:
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
list.forEach(n -> System.out.println(n));
```

```java
// Новый способ с использованием оператора двойного двоеточия ::
list.forEach(System.out::println);
```
##### Функциональные интерфейсы 
Функциональным интерфейсом считается интерфейс который, имеет один нереализованный метод.
```java
@FunctionalInterface
public interface Converter<T, N> {
   N convert(T t);
}
```
Аннотация необходима, чтобы сообщить компилятору, что данный интерфейс функциональный и должен содержать не более одного метода.
```java
@FunctionalInterface
public interface Converter<T, N> {

   N convert(T t);

   static <T> boolean isNotNull(T t){
       return t != null;
   }

   default void writeToConsole(T t) {
       System.out.println("Текущий объект - " + t.toString());
   }

   boolean equals(Object obj);
}
```
Этот интерфейс все еще функциональный, так как статичные методы, методы по умолчанию и методы наследуемые от класса Object разрешены.

###### Базовые функциональные интерфейсы Java 8
Predicate базовый функциональный интерфейс для проверки соблюдения условия.
```java
Predicate<Integer> isEven = x -> x % 2 == 0;
System.out.println(isEven.test(4));
//вывод в консоль "true"
```

Consumer функциональный интерфейс, который принимает объект T, совершает какие-то действия и ничего не возвращает.
```java
Consumer<Integer> consumer = i -> System.out.println(++i+"test");
consumer.accept(1);
//вывод в консоль "2test"
```
Supplier не принимает никаких аргументов, но возвращает объект типа T
```java
Supplier<Integer> random = () -> {
            int value = list.get((int) (Math.random() * list.size()));
            return value;
};
System.out.println(random.get());
//вывод в консоль "4"
```
Function принимает аргумент типа T и приводит его к типу R и возвращает его 
```java
Function<String,Integer> converter = Integer::parseInt;
int test=converter.apply("1");
test++;
System.out.println(test);
System.out.println(converter.apply("123"));
//вывод в консоль 2 и 123
```
UnaryOpertor интерфейс, который принимает объект типа T выполняет над ним операции и возвращает объект того же типа
```java
UnaryOperator<Integer> operator = x -> x * x;
System.out.println(operator.apply(2));
//вывод в консоль "4"
```
Это основные интерфейсы, остальные это усложненные их варианты
###### Функциональные интерфейсы в Stream
* Метод с predicate
Для примера возьмемметод класса stream filterкоторый принимает predicate, а возвращает stream только с теми элементами, которые подходят под условие predicate.
```java
List<Integer> evenNumbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8)
           .filter(x -> x % 2==0)
           .collect(Collectors.toList());
```
В итоге список evenNumbers будет состоять из элементов {2, 4, 6, 8}.
* Метод с Consumer
одним из методов будет peek
```java
List<String> peopleGreetings = Stream.of("Elena", "John", "Alex", "Jim", "Sara")
           .peek(x -> System.out.println("Hello " + x + " !!!"))
           .collect(Collectors.toList());
```
вывод в консоль выглядит так:
Hello Elena !!!
Hello John !!!
Hello Alex !!!
Hello Jim !!!
Hello Sara !!!
* Метод с Supplier
Примером будет generate, который генерирует бесконечную последовательность на основе переданного ему функционального интерфейса.

```java
ArrayList<String> nameList = new ArrayList<>();
   nameList.add("Elena");
   nameList.add("John");
   nameList.add("Alex");
   nameList.add("Jim");
   nameList.add("Sara");

   Stream.generate(() -> {
       int value = (int) (Math.random() * nameList.size());
       return nameList.get(value);
   }).limit(5).forEach(System.out::println);
```
И вот какой мы получим вывод в консоль:
John
Elena
Elena
Elena
Jim
limit(5) необходим чтобы не было бесконечного вывода.
* Метод с Function
Типичный пример map который принимает элементы одного типа, что-то с ними делает и передает дальше,но уже могут быть элементы другого типа.
```java
List<Integer> values = Stream.of("32", "43", "74", "54", "3")
        .map(x -> Integer.valueOf(x)).collect(Collectors.toList());
```
Мы получим список чисел, но уже в формате Integer.
* Метод с UnaryOperator
В качестве примера возьмем iterate, он схож с iterate, но принимает 2 аргумента: первый, с которого начинается генерация последовательности, а второй UnaryOperator который указывает принцип генерации новых значений.
```java
Stream.iterate(9, x -> x * x)
           .limit(4)
           .forEach(System.out::println);
```
Вывод в консоль будет выглядить:
9
81
6561
43046721

# **Модуль 2**
## 1.	Исключения
Исключения — это механизм обработки ошибок во время выполнения программы. Вместо того чтобы программа аварийно завершалась, Java позволяет перехватывать и обрабатывать ошибки.
## 2.	Иерархия исключений
Все исключения в Java — это объекты, унаследованные от класса Throwable.

Throwable
1. Error // Критические ошибки JVM (не обрабатываются)
2. Exception
* CheckedException  // Проверяемые (нужно обрабатывать)
* UncheckedException (RuntimeException) // Непроверяемые (можно не обрабатывать)

Проверяемые исключения (Checked)
Компилятор требует обработку (try-catch) или проброс (throws)
Примеры:
* IOException
* SQLException
* FileNotFoundException
```java
public void readFile(String path) throws IOException {
    BufferedReader reader = new BufferedReader(new FileReader(path));
    System.out.println(reader.readLine());
}
```
Непроверяемые исключения (Unchecked)
Наследуются от RuntimeException
Не требуют обязательной обработки
Примеры:
* NullPointerException
* ArrayIndexOutOfBoundsException
* IllegalArgumentException
```java
public void divide(int a, int b) {
    System.out.println(a / b); // может выбросить ArithmeticException
}

```
## 3.	Способы обработки исключений
```java
try {
    // код, который может выбросить исключение
} catch (IOException e) {
    // обработка исключения
} finally {
    // выполняется всегда (например, закрытие ресурсов)
}
```
Мы можем пробросить исключение выше
```java
public void connect() throws SQLException {
    // ...
}
```
Также мы можем создать свое собственное исключение
```java
public class InvalidUserInputException extends Exception {
    public InvalidUserInputException(String message) {
        super(message);
    }
}
```
* multi-catch: можно ловить несколько исключений в одном блоке
* try-with-resources: автоматическое закрытие ресурсов (AutoCloseable)
* throw: используется для явного выбрасывания исключения
## 4.	try с ресурсами
Это конструкция для безопасной работы с ресурсами, особенное файлами, потоками, соединениями. Она автоматически закрывает, когда блок завершил работу даже если произошло исключение.
Работает с объектами которые реализовывают интерфейс AutoCloseable или Closeable
```java
try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
    System.out.println(reader.readLine());
} catch (IOException e) {
    e.printStackTrace();
}
```
После завершения try-блока, reader.close() вызывается автоматически.
Если будет несколько ресурсов они закрываются в обратном порядке
```java
try (
    BufferedReader reader = new BufferedReader(new FileReader("input.txt"));
    BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))
) {
    String line;
    while ((line = reader.readLine()) != null) {
        writer.write(line);
        writer.newLine();
    }
}
```
Все ресурсы будут закрыты в обратном порядке: сначала writer, потом reader
## 5.	Ввод - вывод
## 6.	Какие основные классы используются для работы с потоками ввода - вывода
## 7.	Основные правила во время работы с потоками ввода - вывода.
## 8.	Сериализация
## 9.	Сборщики проектов(Gradle, Maven)
## 10.	Этапы сборки в Maven
## 11.	Где на локальной машине хранятся скачанные зависимости
