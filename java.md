# **Модуль 1**

##    1.	**JVM, JRE, JDK**
Jvm это java virtual machine – виртуальная машина переводит байт-код в машинный, который после выполняется операционной системой именно благодаря этому достигается кроссплатформенность.
JRE(Java Runtime environment) это пакет, который предоставляет минимальную среду для выполнения Java приложений(JRE=JVM+библиотеки).
JDK(Java development kit) это полный набор инструментов для разработки, компиляции, отладки и запуска Java приложений. Состоит из JRE и инструментов разработки.
Инструменты разработки:
   1.	Компилятор, который переводит java код в байткод (файлы java в class)
   2.	Java application launcher запускает приложения используя JVM и JRE
   3.	Java debugger отладчик для поиска ошибок
   4.	Генерация документации
      5.	Jar для создания и управления jar архивами 

##    2.	**Области памяти в java**

Память, которую использует JVM разбита на 5 основных областей:
   1.	Куча(Heap)это область памяти которая доступная каждому потоку(глобальная память) хранит все объекты и массивы(созданные при помощи слова new). Память в куче контролируется сборщиком мусора
   2.	Стек (stack) используется для выполнения потоков(у каждого потока свой стек), порядок в стеке работает по принципу последним пришел, первым ушел(Last in First out LIFO) это делает выделения и освобождение памяти очень быстрым. Стек хранит фреймы в фрейме хранятся локальные переменные, параметры(аргументы) метода, частичные вычисления и точка возврата(куда нужна вернуться после завершения метода) фрейм создается при каждом вызове метода и уничтожается по завершению.
   3.	Область методов хранит структуру всех загруженных классов и интерфейсов, информацию о полях и методах, статические переменные и пул констант времени выполнения. Эта область доступна для каждого потока
   4.	Регистр счетчик программы хранит адрес на следующую инструкцию байткода для текущего потока. Каждый поток имеет свой собственный регистр PC(program counter) 
   5.	Стек нативных методов хранит нужен для возможности использовать нативные методы. Каждый поток имеет свой нативный стек

##   3.	**Class Loaders. Виды, для чего нужны**

Это механизм загрузки классов, который позволяет динамически загружать классы в память когда они необходимы, а не все сразу. Загрузчики создают пространство имен для каждого класса это позволяет использовать несколько версий одного класса, также они отделяют пользовательские классы от системных. Существует 3 основных загрузчика классов:
      1. Bootstrap самый первый и родительский, загружает основные библиотеки JAVA, является частью JVM, написанный на нативном коде
      2. Extension(загрузчик расширений) дочерний по отношению к bootstrap и загружает классы из $JAVA_HOME/jre/lib/ext/ для дополнительных возможностей 
      3. Системный загружает классы специфичные для вашего приложения, он ищет классы в Class path
      4. Пользовательские. Пользователи сами могут создать загрузчик наследуя от класса ClassLoader позволяет загружать классы из нестандартных мест например из сети, бд, зашифрованных jar

## 4.Объект класса Class

 Объект Class это описание самого типа, какие поля содержит, методы, конструкторы, интерфейсы, суперкласс, пакет, аннотации 
Получить объект Class можно при помощи:
1.	.class <String> stringClass = String.class;
2.	через метод getClass()
String s = "Hello";
 Class<?> objectClass = s.getClass();
3.	через статический метод forName()
Class<?> classObj = Class.forName("java.util.HashMap");
Метод Class	Описание
getName()	Возвращает полное имя класса (с пакетом).
getSimpleName()	Возвращает имя класса без имени пакета.
getSuperclass()	Возвращает объект Class суперкласса.
getInterfaces()	Возвращает массив объектов Class реализованных интерфейсов.
getFields(), getMethods(), getConstructors()	Возвращают массивы объектов Field, Method и Constructor (публичные).
getDeclaredFields(), getDeclaredMethods(), getDeclaredConstructors()	Возвращают все объявленные элементы, включая приватные.
newInstance() (устарел) или getDeclaredConstructor().newInstance()	Создает новый экземпляр этого класса.

## 5. Классы и объекты

Класс это описание сущности: какие поля должна содержать, какие методы реализованы.
Объект это экземпляр класса который обладает своим состоянием и своими значениями.
Интерфейс это набор методов класса доступные для использования.
Пример: человек это класс у него есть рост, вес, возраст, имя, пол, а вот конкретный человек Саша,29,180,90,мужчина это объект(экземпляр класса) и он умеет рисовать, читать, писать это как раз интерфейс
`class Car {// Поля (состояние/атрибуты)
    String model;
    String color;
    int speed;

    // Методы (поведение)
    void startEngine() {
        // Логика запуска двигателя
    }

    void accelerate(int increase) {
        speed += increase;
    }}
Объект
Car car1 = new Car(); // Объект 1

// Объект 1: имеет свое уникальное состояние
car1.model = "Toyota";
car1.color = "Red";
car1.speed = 0;`

## 6. Структура класса

Структура класса состоит из:
1.	Модификатора доступа (откуда будет виден класс) обычно это public виден в любом месте
2.	Ключевого слова Class обязательное для определения
3.	Название класса с заглавной буквы(Person)
4.	Наследование (extends) указывает на родительский класс 
5.	Интерфейсы (implements) указывается какие интерфейсы класс должен реализовать
Пример:
`public class ClassName extends SuperClass implements Interface1, Interface2 {
    // Тело класса
}`

Класс может содержать поля, методы и вложенные классы

## 7. Поля

Поля это данные которые содержит сущность например у класса человек есть поля возраст, рост, имя 

## 8. Конструкторы(ключевое слово super и this)

Конструктор это метод которые вызывается при создании экземпляра класса, их может быть несколько, его задача инициализация, задать начальные значения полям объекта. У него нет возвращаемого типа данных и если вы не напишите сами конструктор, будет использоваться конструктор по умолчанию.
Ключевое слово this ссылается на текущий экземпляр класса внутри которого оно используется.
Пример:
public Car(String color) {// 'color' справа — это параметр метода
    // 'this.color' слева — это поле экземпляра класса
    this.color = color;}
Можно использовать для вызова другого конструктора this(…)
Слово super используется для доступа к членам родительского класса, конструкторы не наследуются и первым инструкцией в теле должно быть super(…) таким образом вызывается родительский конструктор.
Пример:
`class Vehicle {    String type;
    public Vehicle(String type) {        this.type = type;    }
}

class Car extends Vehicle {
    int doors;

    public Car(String type, int doors) {
        super(type); // ⬅️ Вызывает конструктор Vehicle(String)
        this.doors = doors;
    }
}`
Также можно вызывать методы родителя и получать доступ к полям.

## 9. Методы(сигнатура методов, перегрузка методов)

Сигнатура метода включает в себя имя и список аргументов (!!!возвращаемый тип данных и модификатор доступа не входит в сигнатуру метода)
public void say(String message)
Сигнатура здесь будет say(string)
Перегрузка метода это возможность использовать несколько методов с одинаковым именем, но разными сигнатурами. Это достигается изменением сигнатуры: разный порядок параметров (если типы отличаются), разный тип параметров, разное количество параметров.
Перегрузка (Overloading) происходит в одном классе, это механизм полиморфизма

## 10. Статические и нестатические блоки инициализации

Нестатические блоки инициализации — это блоки кода заключенные в фигурные скобки «{}» внутри класса и до конструктора, выполняется каждый раз при создании нового экземпляра класса при помощи new, 
пример:
`public class NonStaticDemo {    private int counter;
    
    // Нестатический блок инициализации
    {
        counter = 1;
        System.out.println("Нестатический блок выполнен. Counter: " + counter);
    }
    
    public NonStaticDemo() {
        System.out.println("Конструктор выполнен.");
    }
    }`
Статические блоки инициализации вызываются один раз для загрузки в JVM при первом создании экземпляра класса или при первом доступе к статическому полю и заключены в фигурные скобки «{}» но перед блоком еще нужно ключевое слово static, выполняется до конструкторов и до любых нестатических блоков
Пример:
`public class StaticDemo {    private static int loadCount;

    // Статический блок инициализации
    static {
        loadCount = 0;
        System.out.println("Статический блок выполнен. Класс загружен.");
    }
    
    public StaticDemo() {
        loadCount++;
        System.out.println("Объект создан. Общее количество: " + loadCount);
    }
}`

## 11. Модификаторы

Модификаторы — это ключевые слова, которые добавляются к определению классов, полей, методов, конструкторов. Они делятся на модификаторы доступа, которые определяют уровень видимости и модификаторы не доступа они определяют другие характеристики не связанные с уровнем видимости

## 12. static, final, abstract

**Static** говорит о том что поле или метод принадлежит классу, а не конкретному объекту, для всех объектов существует только она копия статического поля.

**Final** запрещает наследование, переопределение и изменение 
Для классов значит что запрещено наследование.
Для полей это значит что поле будет константой(значение присвоено один раз)
Для методов что он не может быть переопределен в подклассах.

**Abstract** используется для создания абстрактных структур(шаблонов)
Для класса нельзя создать объект этого класса, он может содержать абстрактные методы.
Для метода не пишется реализация, а только объявляется и подкласс обязан его реализовать.

## 13. private, protected, public, package private

Private виден только в классе
Protected виден только том же классе, подклассах, в том же пакете
Public виден везде
Package private ставится по умолчанию, виден только в том же пакете

## 14. Варианты установки значений свойств объектов

Варианты делятся на два основных этапа: инициализация (пи создании объекта) и изменение(после создания)
1. через конструктор 
`public class Book {
    private String title;
    
    // Конструктор
    public Book(String title) {
        this.title = title; // Установка значения через параметр
    }
} `
2. нестатический блок инициализации
`public class Box {
    private int volume;
    
    // Блок инициализации
    {
        this.volume = 100; // Установка значения по умолчанию
    }`
3. прямая инициализация 
`public class Person {
    private String species = "Human"; // Прямая инициализация
    private int age = 0;
}`
4. при помощи сеттера 
`public class Person {
    private int age;
//сеттер для возраста	
public void setAge(int age){
	this.age=age;
}
}`
5. прямой доступ к полю
`public class Person {
    public int age;
}
Person person=new Person();
person.age=10;`

## 15. Поля, конструктор, сеттеры(плюсы, минусы каждого)

Поля это переменная в классе, изменение ее через прямой доступ(самый быстрый и простой синтаксис из минусов это нарушение инкапсуляции, невозможно валидировать данные, изменение имени поля приводит к тому что нужно менять везде где используется)
Конструктор +:гарантирует что объект создается валидным и  полным, обеспечивает неизменяемость если поля final
Минусы: 
1. при большом количестве полей конструктор может быть большим
2. Не позволяет изменять поля
3. Требует перегрузки для набора разных параметров 
Сеттеры

###### Плюсы:

Позволяет проводить валидацию
Позволяет изменять поля после его создания
Обеспечивает инкапсуляцию

###### Минусы:

Не всегда нужен если объект final 

## 16. Абстрактные классы и интерфейсы(отличия, где что лучше использовать)

##### Отличия:

1. классы могут наследовать только один абстрактный класс, но при этом могут реализовывать множество интерфейсов
2.  в абстрактном классе может быть частичная реализация, когда как интерфейс полностью абстрактный.
3.  в абстрактном классе могут быть любые поля, а в интерфейсе только public static final константы 
4.  в абстрактном классе есть конструктор, в интерфейсе нет
5.  связь при использовании абстрактного класса тесная иерархия, используя интерфейсы будет контрактная связь («может делать»)

##### Когда что использовать:

###### Абстрактные классы:

1. когда требуется тесная связь(Animal->cat,dog)
2. общий код(базовая реализация)
3. для хранения состояния 

###### Интерфейсы:

1. для определения контракта
2. множественное поведение например: пингвин может плавать и есть 
3. отделить определение от реализации
4. гибкость другие разработчики смогут добавлять реализацию контракта  не будучи ограниченными иерархией

## 17. Изменяемые и неизменяемые объекты(примеры неизменяемых классов в java, как сделать класс неизменяемым)

Неизменяемые объекты(immutable) — это объекты состояние которых нельзя изменить, любая операция, которая должна изменить объект, на самом деле возвращает новый объект, а исходный остался нетронутым
Плюсы:
Потокобезопасность так как объект неизменяемый не нужно заботиться о синхронизации
Простота кэширования такой объект можно легко кэшировать и его хеш-код вычислять один раз
Идеально подходят для ключей так как хеш код не меняется (HashMap, HachSet)
Примеры: String, классы обертки (Integer, Double, Boolean, Character), BigDecimal, BidInteger, классы дат и времени LocalDate, LocalTime, ZonedTimeZone и т.д.
Изменяемые (mutable) объект может изменяться после его создания.
Примеры:
StringBuilder, StringBuffer для работы со строками
Большинство коллекций HashMap,ArrayList

##### Чтобы сделать класс неизменяемым нужно

1. его объявить с использованием final(это предотвращает наследование так как подкласс мог бы переопределить методы) 
2. все поля private final чтобы private скрывает поля, final делает их неизменяемыми
3.  отсутствие методов сетторов чтобы нельзя было изменить поля класса
4.  инициализировать поля в конструкторе, гарантирует, что объект будет инициализирован в момент создания 
5.  глубокое копирование изменяемых полей
Если класс имеет ссылку на изменяемый объект,мы должны избежать его изменения и делать копирование:
В конструкторе не сохранять прямую ссылку, вместо этого сохранять копию
В геттере возвращать копию объекта
Пример:
`import java.util.Date;

public final class ImmutableStudent { // 1. Класс final
    
    private final int id;             // 2. Поля private final
    private final String name;        // 2. Поля private final
    private final Date birthDate;     // 2. Поле - ссылка на изменяемый объект Date

    // 4. Инициализация только в конструкторе
    public ImmutableStudent(int id, String name, Date birthDate) {
        this.id = id;
        this.name = name;
        // 5a. Глубокое копирование: сохраняем копию Date
        this.birthDate = new Date(birthDate.getTime());
    }
    
    // 3. Нет сеттеров
    
    // Геттеры
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Date getBirthDate() {
        // 5b. Глубокое копирование: возвращаем копию Date
        return new Date(this.birthDate.getTime());
    }
}   
`
## 18. Inner и Nested классы

Вложенные классы (Nested) — это класс, объявленный внутри другого класса, они бывают двух видов: Статические вложенные (static nested class) и внутренние класс (inner class) 
Статический вложенный класс объявляется со словом static. Он не имеет доступ к нестатическим полям и методам внешнего класса, только к статическим, создается при помощи имени внешнего класса даже без создания его экземпляра.
Внутренний класс — это нестатический вложенный класс
Он всегда связан с конкретным экземпляром внешнего класса и имеет полный доступ к его полям и методам (даже private ) 

## 19. Локальные и анонимные классы

Локальный это класс, объявленный внутри метода или другого блока
Виден только внутри метода или блока, где инициализирован
Имеет доступ ко всем полям внешнего класса, потому что связан с экземпляром класса
Нельзя использовать private, public, protected
Пример:
`public class Outer {
    void display() {
        int limit = 100; // Эффективно final
        
        class LocalPrinter { // ⬅️ Локальный класс
            public void print() {
                System.out.println("Limit from method: " + limit); // Доступ к 'limit'
            }
        }
        
        LocalPrinter lp = new LocalPrinter();
        lp.print();
    }
}`
Анонимный класс — это класс который не имеет имени используется для создания объекта чтобы реализовать интерфейс или абстрактный/конкретный класс
 Выражение new InterfaceName/ClassName() { ... } создает и немедленно возвращает единственный экземпляр анонимного класса.
Нельзя создать второй экземпляр такого класса
Не может объявлять конструктор так как не имеет имени 
Пример:
`interface Greeting {
    String greet();
}

public class AnonDemo {
    public void executeGreeting() {
        // ⬅️ Анонимный класс, реализующий интерфейс Greeting
        Greeting spanishGreeting = new Greeting() { 
            @Override
            public String greet() {
                return "Hola!";
            }
        }; 
        System.out.println(spanishGreeting.greet());
    }
}`
	Сейчас обычно используется лямбда-выражение 

## 20. Класс Object

Это корень иерархии всех классов в Java, все классы явно или неявно наследуются от класса Object. Это означает что каждый объект наследует методы Object.

## 21. Методы класса Object

1.	`Equals(obj)` используется для сравнения на логического равенство двух объектов по умолчанию сравнивает по ссылке(указывают ли на один объект в памяти), почти всегда необходимо переопределять для того, чтобы сравнивать на основе их состояния.
2.	`hachCode()` используется чтобы вернуть хеш-код объекта для эффективного хранения и поиска объектов в хеш-коллекциях(HashSet, HashMap), если вы переопределили equals(), вы обязаны и переопределить и hashCode(если объекты равны по equals, то они обязаны иметь один хеш-код)
3.	`toString()` создает и возвращает копию объекта, обычно возвращает имя класса и после знака @ хеш-код, обычно переопределяется чтобы получать полезную и читаемую информацию
4.	`clone()` создает и возвращает копию объекта, требуется чтобы класс реализовал интерфейс Cloneable(который является маркерным и интерфейсом, не имеющий  методов), выполняет поверхностное копирование
5.	`wait(), notify(),notifyAll()` используются для межпоточного взаимодействия, должны вызываться только внутри синхронизированного блока или метода так как работают с блокировкой объекта
Класс Object так важен, потому что от него наследуются все классы и любой объект может быть обработан как Object
Любая коллекция может хранить любой тип, потому что ее методы add(Object e) работают с общим родительским  типом. Это основа для обобщенного программирования в Java.

## 22. Контракт equals – hashcode

Контракт это набор правил которые должны быть выполнены для переопределния методов equals(), hashcode()
1.	Согласованность если объекты равны по equals, то и хеш-коды должны быть одинаковыми
2.	Если два хеш-кода равны это не гарантирует, что они равны по equals, это называется коллизией хеш-кодов. Хеш-код используется для быстрого поиска, а equals для окончательной проверки
3.	Если информация, используемая в сравнении equals не изменилась, то многократный вызов hashCode() должен возвращать один и тот же хеш-код
Нарушение правил ведет к не предсказуемому поведению, например изменение хеша после его помещения в таблицу придет к тому, что объект потеряется в памяти и его нельзя будет получить по ключу, но он будет занимать память
Рекомендации: 
	Использовать одни и те же поля в equals() и hashCode(), для неизменяемых объектов хранит хеш-код в final поле

## 23. Метод clone

Clone() создает и возвращает копию объекта, для его использования класс должен реализовывать интерфейс Cloneable,так как clone() в Object объявлен protected, мы должны переопределить его с модификатором public чтобы могли использовать вне класса.
Есть два типа копирования:
1.	Поверхностное копирование оно копирует значения примитивных полей и ссылок на объекты, это приводит к тому, что если у одного клона изменить значение вложенного объекта он измениться во всех клонах
2.	Глубокое копирование требует ручной реализации, вызывается super.clone() для поверхностного копирования, для всех изменяемых ссылочных типов создается и присваиваются новые экземпляры, в результате клонированный объект полностью независим от оригинала.
Пример глубокого копирования:
`@Override
    public Object clone() throws CloneNotSupportedException {
        // 1. Поверхностное копирование: создается новый объект Person и копируются поля name и ссылка address
        Person clonedPerson = (Person) super.clone();
        
        // 2. Глубокое копирование: создается новая копия объекта Address
        // Это предотвращает совместное использование Address оригиналом и клоном.
        clonedPerson.address = (Address) this.address.clone();
        
        return clonedPerson;
    }`
Как альтернатива можно использовать конструктор копирования где мы просто копируем поля экземпляра.

Пример:

`public Person(Person other) {
    this.name = other.name;
    this.address = new Address(other.address.getCity()); // Вручную создаем копию Address
} `

## 24. Принципы ООП

1.	Инкапсуляция — это сокрытия методов и полей от пользователя
2.	Полиморфизм позволяет нам использовать объекты с одинкавоыми интерфейсами без знаний структуры и типа объекта.
3.	Наследование позволяет нам наследовать поля и методы от класса родителя
4.	Абстракция позволяет нам выделить общие характеристики и методы в один класс, а после наследоваться от него
 
## 25. Наследование и Ассоциация (определение, плюсы-минусы каждого)

Наследование  механизм, при котором один класс получает свойства и методы другого класса( отношение «является») например dog является animal, родитель animal и дочерний класс dog.

###### Плюсы:

* Повторное использование кода, так как дочерний класс имеет доступ к полям и методам родителя
* Полиморфизм позволяет использовать объект дочернего класса где ожидается родительский
* Создает четкую иерархию классов

###### Минусы:

* Тесная связь: любое изменение в классе родителе отразиться на дочернем, кроме добавления методов
* Java поддерживает только одиночное наследование
* Нарушение инкапсуляции, так как раскрываем детали реализации родителя

Ассоциация — это общее понятие, описывающее структурную связь между двумя или более классами (отношение «имеет»), реализуется через композицию или агрегацию, класс содержит ссылку на другой класс в виде поля, это позволяет использовать функциональность другого объекта.
В композиции отношение «часть-целое» где часть не может существовать без целого, при уничтожении целого уничтожается и часть
В агрегации отношение такое же, но часть может существовать без целого 

###### Плюсы:

* Классы слабо зависят друг от друга, что упрощает изменения
* Гибкость: позволяет легко изменять какой объект использовать (можно заменить объект на другой)
* Инкапсуляция: внутренние детали ассоциированного объекта скрыты

###### Минусы:

* Требуется ручное написание кода для делегированного вызова ассоциированному объекту
* Для реализации сложных отношений может потребоваться написать больше кода чем при простом наследовании
###### Сравнение ассоциации и наследования:

* Отношение: в наследовании это «является» в ассоциации это включение («имеет»)
* Связанность: в наследовании тесная, в ассоциации слабая
* Принцип ООП: полиморфизм, повторное использование кода в наследовании и инкапсуляция, делегирование в ассоциации 

## 26. Переопределение методов

Переопределение методов — это механизм Java позволяющий дочернему классу предоставлять собственную реализацию метода, который определен в родительском классе

###### Правила переопределения:
1.	Сигнатура метода должна сохраняться (такая же как в родительском классе)
2.	Метод должен быть определен в родительском классе и дочерний должен его наследовать
3.	Переопределенный метод не может иметь более ограничивающий модификатор доступа чем в суперклассе, например если в родителе protected, то у потомка protected или public 
4.	Переопределенный метод не должен объявлять новые исключения, он может использовать меньше чем в родителе или подклассы исключений
5.	Методы, объявленные как private, static, final не могут быть переопределены 

Рекомендуется использовать аннотацию @override так компилятор поймет, что вы переопределяете метод и выдаст ошибку в случае ошибки в сигнатуре 
Благодаря этому реализуется динамическая диспетчеризация: JVM решает какой метод вызвать во время выполнения, а не компиляции основываясь на фактическом типе объекта, на который ссылается переменная например:

`Animal myAnimal = new Dog(); // Ссылка типа Animal, объект типа Dog
myAnimal.makeSound(); // Вызовет Dog.makeSound() -> "Dog barks."
// Если бы не было переопределения, был бы вызван метод Animal. ` 

## 27. Статическое и динамическое связывание

Связывание — это процесс сопоставления вызова метода с его конкретной реализацией. В Java оно может быть статическим (во время компиляции) и динамическим ( во время выполнения)  
Статическое связывание происходит во время компиляции, компилятор выбирает реализацию на основе типа ссылки.

###### Когда происходит:

1.	Статические методы, потому что они принадлежат классу 
2.	Final методы они не могут быть переопределены 
3.	Private методы они не наследуются и не могут быть переопределены
4.	Поля: доступ к полям всегда происходит статически
5.	Перегрузка методов: компилятор выбирает на основе типов аргументов во время компиляции
Динамическое связывание происходит во время выполнения JVM определяет какой метод вызвать на основе фактического типа объекта, на который ссылается переменная, происходит обычно с переопределенными методами

## 28. Оболочки примитивных типов. Основное API. Особенности сравнения значений.

Оболочки примитивных типов это классы которые предоставляют объектный эквивалент для каждого примитивного типа(int->Integer, Boolean->Boolean, chra->Charactet)
Автоупаковка и автораспаковка это автоматический процесс преобразование примитивного типа в его объектную оболочку и наоборот

###### Основное API:
1.	Методы преобразования эти методы используются для преобразования строки в примитивный тип (parseInt(String s)) 
2.	Методы получения значений каждый класс-оболочка имеет метод для получения своего значения в виде примитивов (intValue())
3.	Методы преобразования в объект: эти методы используется для преобразования примитивов или строк в объект оболочку, они могут использовать кеш valueOf(int i) , valueOf(String s)
4.	Большинство числовых оболочек предоставляют константы Integer.MAX_VALUE , Double.NEGATIVE_INFINITY

###### Особенности сравнения значений 
1.	Оператор сравнения «==» сравнивает ссылки двух объектов 
`Integer a = 100;
Integer b = 100;
System.out.println(a == b); // true

Integer c = 500;
Integer d = 500;
System.out.println(c == d); // false`
Большинство классов оболочек (кроме Double и Float) кэшируют данные в диапазоне -128 до 127
2.	Для логического сравнения необходимо использовать equals()
3.	Смешанное сравнение (примитив и оболочка), при таком сравнении оболочка автоматически распаковывается до примитива.


## 29. String

String это неизменяемый класс, который содержит последовательность символов. String неизменяемый это значит что при любом действие которое казалось бы изменяет строку, на самом деле создает новый объект. Это обеспечивает потокобезопасность и также позволяет использовать пул строк.

## 30. String pool

Пул строк — это специальная область в памяти(куче) для литералов.
Если мы создаем строку литералом
 `String s = "Hello";`
То вначале JVM проверяет пул на наличии такого литерала и если он есть возвращает ссылку на существующий объект в памяти, если же нет, то создает его и возвращает ссылку. Когда мы создаем строку при помощи new всегда создается новая строка в куче (вне пула) даже если строка там есть.
При помощи метода `intern()` мы можем строку переместить из кучи в пул, если такая строка уже есть в пуле, мы вернем ссылку на объект.

## 31. API

`equals(Object other)` Сравнивает содержимое строк (регистрозависимо).
`equalsIgnoreCase(String other)` Сравнивает содержимое строк (без учета регистра).
`compareTo(String other)` Сравнивает строки лексикографически (используется для сортировки).
`indexOf(char/String)`	Возвращает индекс первого вхождения символа/подстроки.
`contains(CharSequence s)`	Проверяет, содержит ли строка указанную последовательность.
`substring(int begin, int end)`	Возвращает новую строку — подстроку.
`replace(char old, char new)`	Возвращает новую строку с заменой символов.
`trim()`	Возвращает новую строку, удаляя начальные и конечные пробелы.
`length()`	Возвращает длину строки.
`charAt(int index)`	Возвращает символ по указанному индексу.
`toUpperCase(), toLowerCase()`	Возвращает новую строку в верхнем/нижнем регистре.
`split(String regex)`	Разбивает строку на массив строк по заданному разделителю (регулярному выражению).
